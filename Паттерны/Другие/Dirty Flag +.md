#otherpatterns 
Набор первичных данных изменяется с течением времени. Набор производных данных определяется из этого с помощью некоторого дорогостоящего процесса . Грязный флаг отслеживает, когда производные данные не синхронизированы с первичными данными. Он устанавливается, когда первичные данные изменяются . Если флаг устанавливается, когда производные данные необходимы, то они перерасчитываются, и флаг очищается. В противном случае используются предыдущие кэшированные производные данные .

Как и большинство оптимизаций, вы должны обращаться к нему только тогда, когда у вас есть проблема с производительностью, достаточно большая, чтобы оправдать добавленную сложность кода. Этот шаблон жертвует памятью ради скорости. В обмен на сохранение ранее рассчитанных данных в памяти, вы избегаете необходимости пересчитывать их, когда они не менялись. Этот компромисс имеет смысл, когда расчет медленный, а память дешевая. Когда у вас больше времени, чем памяти, лучше вычислять по мере необходимости.

Грязные флаги применяются к двум видам работы: _вычислениям_ и _синхронизации_ . В обоих случаях процесс перехода от первичных данных к производным данным является трудоемким или иным образом дорогостоящим.

Есть еще несколько требований:
- **Первичные данные должны меняться чаще, чем используются производные данные.** Этот шаблон работает, избегая обработки производных данных, когда последующее изменение первичных данных сделает их недействительными до того, как они будут использованы. Если вы обнаружили, что вам всегда нужны эти производные данные после каждой модификации первичных данных, этот шаблон не поможет.
    
- **Должно быть сложно обновлять пошагово.** Допустим, пиратский корабль в нашей игре может перевозить только определенное количество добычи. Нам нужно знать общий вес всего в трюме. Мы _могли бы_ использовать этот шаблон и иметь грязный флаг для общего веса. Каждый раз, когда мы добавляем или удаляем какую-то добычу, мы устанавливаем флаг. Когда нам нужна общая сумма, мы суммируем всю добычу и очищаем флаг.
    
    Но более простое решение — сохранять _текущий итог_ . Когда мы добавляем или удаляем элемент, просто добавляем или удаляем его вес из текущего итога. Если мы можем «платить по мере использования» и обновлять производные данные, то это часто лучший выбор, чем использовать этот шаблон и вычислять производные данные с нуля, когда это необходимо.

> Это отражает различные стратегии сборки мусора в системах, которые автоматически управляют памятью. Подсчет ссылок освобождает память в ту секунду, когда она больше не нужна, но он сжигает время ЦП, жадно обновляя счетчики ссылок каждый раз, когда ссылки изменяются.
> 
> Простые сборщики мусора откладывают освобождение памяти до тех пор, пока она действительно не понадобится, но за это приходится платить ужасной «паузой сборки мусора», которая может заморозить всю игру, пока сборщик мусора не закончит очистку кучи.
> 
> Между ними находятся более сложные системы, такие как отложенный подсчет ссылок и инкрементальная сборка мусора, которые освобождают память менее активно, чем чистый подсчет ссылок, но более активно, чем останавливающие мир сборщики мусора.

## Слишком долгое откладывание имеет свою цену
Этот шаблон откладывает некоторую медленную работу до тех пор, пока результат не понадобится, но когда он нужен, он часто нужен _прямо сейчас_ . Но причина, по которой мы используем этот шаблон, заключается в том, что вычисление этого результата происходит медленно. 

В некоторых случаях, если игра не _начнет_ пережевывать до того момента, когда игрок ожидает увидеть результат, это может вызвать неприятную видимую паузу.

Другая проблема с отсрочкой заключается в том, что если что-то пойдет не так, вы можете вообще не выполнить работу. Это может быть особенно проблематично, когда вы используете этот шаблон для сохранения некоторого состояния в более устойчивой форме.


## Вам нужно убедиться, что флаг установлен каждый раз, когда меняется состояние
Если пропустить его в одном месте, ваша программа будет неправильно использовать устаревшие производные данные. Это приводит к путанице в игроках и ошибкам, которые очень трудно отследить. При использовании этого шаблона вам придется позаботиться о том, чтобы любой код, который изменяет первичное состояние, также устанавливал грязный флаг.

Один из способов смягчить это — инкапсулировать изменения первичных данных за каким-то интерфейсом. Если что-то, что может изменить состояние, проходит через один узкий API, вы можете установить там грязный флаг и быть уверенным, что это не будет пропущено.

## Когда очищать грязный флаг?
- **Когда нужен результат:**
    - _Это полностью избегает выполнения вычислений, если результат никогда не используется._ Для первичных данных, которые изменяются гораздо чаще, чем происходит доступ к производным данным, это может быть большим выигрышем.
        
    - _Если расчет занимает много времени, это может вызвать заметную паузу._ Откладывание работы до тех пор, пока игрок не начнет ожидать увидеть результат, может повлиять на его игровой опыт. Часто это происходит достаточно быстро, поэтому это не проблема, но если это так, вам придется сделать работу раньше.

- **На четко определенных контрольно-пропускных пунктах:**
    Иногда есть момент времени или в ходе игры, когда естественно выполнить отложенную обработку. Например, мы можем захотеть сохранить игру только тогда, когда пират приплывет в порт. Или точка синхронизации может не быть частью игровой механики. Мы можем просто захотеть скрыть работу за загрузочным экраном или кат-сценой.
    
    - _Выполнение работы не влияет на пользовательский опыт._ В отличие от предыдущего варианта, вы часто можете дать что-то, чтобы отвлечь игрока, пока игра занята обработкой.
        
    - _Вы теряете контроль над тем, когда происходит работа._ Это своего рода противоположность предыдущему пункту. У вас есть микромасштабный контроль над тем, когда вы обрабатываете, и вы можете быть уверены, что игра справится с этим изящно.
        
        Чего вы _не можете_ сделать, так это гарантировать, что игрок действительно доберется до контрольной точки или выполнит любые определенные вами критерии. Если они потеряются или игра придет в странное состояние, вы можете отложить игру на большее время, чем ожидали.

- **На заднем плане:**    
    Обычно вы запускаете фиксированный таймер при первом изменении, а затем обрабатываете все изменения, которые происходят между этим моментом и срабатыванием таймера.
    
    Термин в человеко-машинном взаимодействии, обозначающий преднамеренную задержку между получением программой пользовательского ввода и ее ответом, называется гистерезисом .
    
    - _Вы можете настроить частоту выполнения работы._ Регулируя интервал таймера, вы можете гарантировать, что она будет выполняться так часто (или редко), как вам нужно.
        
    - _Вы можете выполнять больше избыточной работы._ Если первичное состояние изменяется лишь незначительно во время работы таймера, вы можете в конечном итоге обрабатывать большой кусок в основном неизмененных данных.
        
    - _Вам нужна поддержка для выполнения работы асинхронно._ Обработка данных «в фоновом режиме» подразумевает, что игрок может продолжать делать то, что он делает, в то же время. Это означает, что вам, скорее всего, понадобится потоковое выполнение или какая-то другая поддержка параллелизма, чтобы игра могла работать с данными, пока она еще воспроизводится.
        
        Поскольку игрок, скорее всего, взаимодействует с тем же первичным состоянием, которое вы обрабатываете, вам нужно подумать о том, чтобы сделать его безопасным для одновременной модификации.

## Насколько точны отслеживания?
Представьте, что наша пиратская игра позволяет игрокам строить и настраивать свой пиратский корабль. Корабли автоматически сохраняются в сети, так что игрок может продолжить с того места, где остановился. Мы используем грязные флаги, чтобы определить, какие палубы корабля были установлены и должны быть отправлены на сервер. Каждый фрагмент данных, который мы отправляем на сервер, содержит некоторые измененные данные корабля и немного метаданных, описывающих, где на корабле произошла эта модификация.

- **Если более подробно:**
    Допустим, вы прикрепили грязный флаг к каждой крошечной планке каждой палубы.
    - _Вы обрабатываете только те данные, которые действительно изменились._ Вы отправите на сервер именно те грани корабля, которые были изменены.

- **Если более грубо:**    
    В качестве альтернативы мы могли бы связать грязный бит с каждой палубой. Изменение чего-либо на ней делает всю палубу грязной .
    - _В итоге вы обрабатываете неизмененные данные._ Добавьте одну бочку на палубу, и вам придется отправить все это на сервер.
        
    - _Меньше памяти используется для хранения грязных флагов._ Добавьте десять бочек на палубу, и вам понадобится только один бит, чтобы отслеживать их все.
        
    - _Меньше времени тратится на фиксированные накладные расходы._ При обработке некоторых измененных данных часто приходится выполнять некоторую фиксированную работу в дополнение к обработке самих данных. В приведенном здесь примере это метаданные, необходимые для определения того, где на судне находятся измененные данные. Чем больше ваши обрабатываемые фрагменты, тем их меньше, а значит, тем меньше у вас накладных расходов.