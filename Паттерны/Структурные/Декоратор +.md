#structural 
Динамически добавляет обязанности объекту. Гибкая альтернатива субклассированию.

## Применять когда
- Динамически добававлять обязанности индивидуальным объектам, без влияния на другие объекты
- Для обязанностей, которые могут быть отозваны.
- Расширение субклассирование непрактично


## Преимущества
- Большая гибкость чем при статическом наследовании
- Позволяет избежать ситуации, когда нужно пытаться заранее добавить всевозможные обязанности.
- Декоратором можно инкрементарно добавлять обязанности
- Поддерживает рекурсивную композицию декораторов
- При использовании декораторов нельзя полагаться на идентичность объектов, так как декоратор и объект разные

## В играх

```cs
public interface ICard
{
	public int Play();
}

public class BattleCard: Icard
{
	private readonly int _value;
	public BattleCard(int value) => _value = value;

	public int Play() => _value;
}

public abstract class CardDecorator: ICard
{
	protected ICard card;
	protected readonly int _value;

	protected CardDecorator(int value)
	{
		_value = value;
	}

	public void Decorate(Icard card)
	{
		if (ReferenceEquals(this, card))
		{
			throw new Exception("Can not decorate self");
		}
	
		if (this.card is CardDecorator decorator)
			decorator.Decorate(card);
		else
			this.card = card;
	}

	public virtual int Play()
	{
		return card is null ? _value : card.Play() + _value;
	}
}


public class DamageDecorator: CardDecorator
{
	
}

public class HealthDecorator: CardDecorator
{
	public override int Play()
	{
		HealPlayer();
		return card?.Play() ?? 0;
	}

	private int HealPlayer()
	{
	}
}

public class CardManager
{
	public ICard selectedCard;

	public void Decorate()
	{
		if (currentCard is CardDecorator decorator)
		{
			decorator.Decorate(selectedCard);
		}
	}
}
```

## Другой пример

```cs
[Flags]
public enum DamageTypes 
{
    Poison = 1 << 0,
    Fire = 1 << 1,
    Electricity = 1 << 2
}

public interface IDamageable
{
   float HitPoints { get; set; }
}
```

```cs
public class Attacker : MonoBehaviour
{
    [SerializeField] private ReactionsManager reactionsManager;
    [SerializeField] private Player defender;
    [SerializeField] private DamageTypes damageTypes;
    
    private void OnMouseDown()
    {
        DamageReactionBase defenderReaction = reactionsManager.CalculateReaction(damageTypes);
        defender.ReactToDamage(defenderReaction);
    }
}
```


```cs
public class Player : MonoBehaviour, IDamageable
{
    public float HitPoints { get; set; }
    
    [SerializeField] private int hitPoints = 100;

    private void Start() => HitPoints = hitPoints;

    public void ReactToDamage(DamageReactionBase damageReaction)
    {
       damageReaction.React(this);
    }
}
```

```cs
public abstract class DamageReactionBase : ScriptableObject
{
    public abstract void React(IDamageable damageable);
}
```

```cs
[CreateAssetMenu(fileName = "BaseDamageReaction", menuName = "DecoratorPattern/BaseDamageReaction")]
public class DamageReaction : DamageReactionBase
{
   [SerializeField] protected float damage;
   
   public override void React(IDamageable damageable)
   {
      damageable.HitPoints -= damage;
      
      Debug.Log($"Got hit for {damage} hp, hp dropped to {damageable.HitPoints}");
   }
}
```

```cs
public abstract class DamageReactionDecorator : DamageReactionBase
{
   private DamageReactionBase _damageReaction;

   public void ChainReaction(DamageReactionBase damageReaction) => _damageReaction = damageReaction;

   public override void React(IDamageable damageable)
   {
      if (_damageReaction != null)
         _damageReaction.React(damageable);
   }
}
```

```cs
[CreateAssetMenu(fileName = "PoisonDamageReaction", menuName = "DecoratorPattern/PoisonDamageReaction")]
public class PoisonDamageReactionReaction : DamageReactionDecorator
{
    public override void React(IDamageable damageable)
    {
        base.React(damageable);
        
        // Behavior for damageable
        Debug.Log("Poison Damage Reaction");
    }
}

[CreateAssetMenu(fileName = "FireDamageReaction", menuName = "DecoratorPattern/FireDamageReaction")]
public class FireDamageReactionReaction : DamageReactionDecorator
{
   public override void React(IDamageable damageable)
   {
      base.React(damageable);
        
      // Behavior for damageable
      Debug.Log("Fire Damage Reaction");
   }
}

[CreateAssetMenu(fileName = "ElectricityDamageReaction", menuName = "DecoratorPattern/ElectricityDamageReaction")]
public class ElectricityDamageReactionReaction : DamageReactionDecorator
{
   public override void React(IDamageable damageable)
   {
      base.React(damageable);
        
      // Behavior for damageable
      Debug.Log("Electricity Damage Reaction");
   }
}
```

```cs
public class ReactionsManager : MonoBehaviour
{
    [SerializeField] private DamageReaction damageReaction;
    [SerializeField] private PoisonDamageReactionReaction poisonDamageReactionReaction;
    [SerializeField] private FireDamageReactionReaction fireDamageReactionReaction;
    [SerializeField] private ElectricityDamageReactionReaction electricityDamageReactionReaction;

    private readonly Dictionary<DamageTypes, DamageReactionDecorator> _reactions = new();

    private void Awake()
    {
        _reactions.Add(DamageTypes.Poison, poisonDamageReactionReaction);
        _reactions.Add(DamageTypes.Fire, fireDamageReactionReaction);
        _reactions.Add(DamageTypes.Electricity, electricityDamageReactionReaction);
    }

    public DamageReactionBase CalculateReaction(DamageTypes damageTypes)
    {
        DamageReactionBase tempReaction = damageReaction;

        foreach (DamageTypes damageType in Enum.GetValues(typeof(DamageTypes)))
        {
            if (!damageTypes.HasFlag(damageType)) continue;

            _reactions[damageType].ChainReaction(tempReaction);
            tempReaction = _reactions[damageType];
        }
        
        return tempReaction;
    }
}
```