#structural 
Общий доступ для большого количества одинаковых объектов

## Применять когда все из нижеперечисленного верно
- Приложение  использует большое количество объектов
- Высокие затраты на память из-за количества объектов
- Большее количество состояний объектов можно вынести
- Большое количество групп объектов можно заменить на мешьнее, если убрать внешнее состояние

## Реализация
- Flyweight Factory отвечает за создание легковесов
- Использовать менеджер легковесов

## Связанное
- Часто комбинируется с [[Компоновщик +]] для реализации логической иерархической структуры в терминах направленного ациклического графа с узлами в общем доступе
- Лучше всего реализовывать объекты [[Состояние +]] и [[Стратегия +]] как легковесы.

## В играх
```cs

// SIMPLE EXAMPLE
public enum FlyweightType { Fire, Ice }

public class Flyweight: MonoBehaviour
{
	public FlyweightSettings settings; // shared among objects	

	private IEnumerator DespawnCoroutine()
	{
		yield return new WaitForSeconds(settings.despawnDelay);
		Destroy(gameObject);
	}
}

[CreateAssetMenu(menuName = "Flyweight/Flyweight Settings)]
public class FlyweightSettings: ScriptableObject
{
	public FlyweightType flyweightType;
	public GameObject prefab;
	public float despawnDelay = 5f;
	public float speed = 10f;

	public Flyweight Create()
	{
		var go = Instantiate(prefab);
		go.SetActive(false);'
		go.name = prefab.name;

		var flyweight = go.AddComponent<Flyweight>)();
		flyweight.settings = this;
		return flyweight;
	}
}

public class Hero
{
	// will be added in inpector
	public List<FlyweightSettings> flyweights;

	public void Update()
	{
		if (Input.GetButtonDown("Fire1"))
			flyweights[0].Create();
		else if (Input.GetButtonDown("Fire1"))
			flyweights[1].Create();
	}
}
```


```cs
// OBJECT POOL EXAMPLE

using UnityEngine.Pool;

public class FlyweightFactory: MonoBehaviour
{
	[SerializeField] private bool collectionCheck;
	[SerializeField] private int defaultCapacity;
	[SerializeField] private int maxPoolSize;
	

	private static FlyweightFactory instance;
	private readonly Dictionary<FlyweightType, IObjectPool<Flyweight>> pool = new();

	private void Awake()
	{
		if (instance is null)
			instance = this;
		else
			Destroy(gameObject);
	}
	
public static Flyweight Spawn(FlyweightSettings s) => instance.GetPoolFor(s)?.Get();

public static Flyweight ReturnToPool(Flyweight f) => instance.GetPoolFor(f.settings)?.Release(f);


	private IObjectPool<Flyweight> GetPoolFor(FlyweightSettings flyweightSettings)
	{
		IObjectPool<Flyweight> pool;
		if (pools.TryGetValue(settings.type, out pool)) return pool;

		pool = new ObjectPool<Flyweight>(
			settings.Create,
			settings.OnGet,
			settings.OnRelease,
			settings.OnDestroyPoolObject,
			collectionCheck,
			defaultCapacity,
			maxPoolSize
		);
	}
}


[CreateAssetMenu(menuName = "Flyweight/Flyweight Settings)]
public class FlyweightSettings: ScriptableObject
{
	public FlyweightType flyweightType;
	public GameObject prefab;
	public float despawnDeay = 5f;
	public float speed = 10f;

	public Flyweight Create()
	{
		var go = Instantiate(prefab);
		go.SetActive(false);'
		go.name = prefab.name;

		var flyweight = go.AddComponent<Flyweight>)();
		flyweight.settings = this;
		return flyweight;
	}

	public void OnGet(Flyweight f) => f.gameObject.SetActive(true);
	public void OnRelease(Flyweight f) => f.gameObject.SetActive(false);
	public void OnDestroyPoolObject(Flyweight f) => Destroy(f.gameObject);	
}


public class Flyweight: MonoBehaviour
{
	public FlyweightSettings settings; // shared among objects	

	private IEnumerator DespawnCoroutine()
	{
		yield return new WaitForSeconds(settings.despawnDelay);
		FlyweightFactory.ReturnToPool(this);
	}
}

```

```cs

// SOME REFACTORING


public class Flyweight: MonoBehaviour
{
	public FlyweightSettings settings; // shared among objects	

}


public class Projectile: Flyweight
{
	new ProjectileSettings settings => (ProjectileSettings) base.settings;

	void OnEnable()
	{
		StartCoroutine(DespawnCoroutine());
	}

	private IEnumerator DespawnCoroutine()
	{
		yield return new WaitForSeconds(settings.despawnDelay);
		FlyweightFactory.ReturnToPool(this);
	}
}


[CreateAssetMenu(menuName = "Flyweight/Flyweight Settings)]
public class FlyweightSettings: ScriptableObject
{
	public FlyweightType flyweightType;
	public GameObject prefab;


	public virtual Flyweight Create()
	{
		var go = Instantiate(prefab);
		go.SetActive(false);'
		go.name = prefab.name;

		var flyweight = go.AddComponent<Flyweight>)();
		flyweight.settings = this;
		return flyweight;
	}

	public virtual void OnGet(Flyweight f) => f.gameObject.SetActive(true);
	public virtual void OnRelease(Flyweight f) => f.gameObject.SetActive(false);
	public virtual void OnDestroyPoolObject(Flyweight f) => Destroy(f.gameObject);	
}



[CreateAssetMenu(menuName = "Flyweight/Projectile Settings)]
public class ProjectileSettings: FlyweightSettings
{
	public float despawnDeay = 5f;
	public float speed = 10f;
	public float damage = 10f;

	public override Flyweight Create()
	{
		var go = Instantiate(prefab);
		go.SetActive(false);'
		go.name = prefab.name;

		var flyweight = go.AddComponent<Projectile>)();
		flyweight.settings = this;
		return flyweight;
	}

}
```

```cs

// TEXTURE AND MESHES
public class TreeModel
{
	private Mesh mesh;
	private Texture bark;
	private Texture leaves;
}

public class Tree
{
	// shared
	private TreeModel model;

	// not shared
	private Vector position;
	private float height;
	private Color barkTint;
	private Color leafTint;
}

```

```cs

// TERRAIN
// BETTER THAN USAGE OF SWITCH CASES AND ARRAY OF ENUMS

public class Terrain
{
	public int MovementCost {get; private set; }
	public bool IsWater {get; private set; }
	public Texture Texture {get; private set; }

	public Terrain(int movementCost, bool isWater, Texture texture)
	{
		MovementCost = movementCost;
		IsWater = isWater;
		this.Texture = texture;
	}
}


public class World
{
	private const grassTerrain = new Terrain(1, false, GrassTexture);
	private const hillTerrain = new Terrain(3, false, HillTexture);
	private const riverTerrain = new Terrain(2, true, RiverTexture);

	private Terrain[][] _terrain = new Terrain[100][];

	public World()
	{
		for (int y = 0; y < 100; y++)
		{
			for (int x = 0; x < 100; x++)
			{
				// use shared instances of terrain
				if (random() == 1)
					_terrain[y][x] = grassTerrain;
				else if (random() == 2)
					_terrain[y][x] = hillTerrain;
				else 
					_terrain[y][x] = riverTerrain;
			}
		}
	}
}

```