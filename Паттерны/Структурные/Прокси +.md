#structural 
Предоставляет оболочку / заменитель для другого объекта для контроля доступа к нему

## Применять когда
- Remote прокси дает локальное представление для объекта в другом адресном пространстве. Альтернативно называется Амбассадором.
- Виртуальный прокси создает дорогостоящие объекты по требованию.
- Защитный прокси контроллирует доступ к оригинальному объекту.
- Smart reference заменяет обычный указатель, типичные случаи
    - Подсчет количества ссылок для освобождения памяти
    - Загрузка постоянного объекта в память при первом обращении к нему
    - Проверка, что реальный объект заблокирован перед доступом к нему чтобы убедиться, что
    другие объекты не изменят его

## Преимущества
+ Позволяет использовать Copy On Write. Копирование сложного объекта может быть дорогой операцией, которая не требуется, если он не был изменен. Использование прокси позволяет отложить копирование до момента изменения объекта. Для этого прокси использует подсчет ссылок, когда клиент обращается к нему, увеличивает количество ссылок. Только при изменении возвращает новый объект. Когда ссылок ноль, объект удаляется.

## Реализация
- Если прокси не является виртуальным (т.е. не будет инстанциировать объект), то можно использовать абстрактный интерфейс, а не конкретный класс.
## В играх

Польза от шаблона:
- Выигрыш в производительности. `MonoBehaviour` работающий как прокси для подмножества типов позволяет избежать необходимости в создании и уничтожении объектов в реальном времени
- Ленивая инициализация
- Условное выполнение. В прокси можно определить условия, при которых будут вызваны методы
- Композиция, а не наследование. Так как `MonoBehaviour` не является прокси для конкретного класса, а для классов с интерфеййсом, мы можем иметь общий код в методах `MonoBehaviour`, которые будут вызваны до или после соответствующих методов каждого класса. По сути, мы заменяем наследование композицией.
- Разделение интересов. Так как каждый вид гоблина имеет свой класс, он имеет только специфическую логику для этого вида.
- Тестируемость. Легче создавать тесты для логики, так как они содержатся в методах как часть обычного класса, а не `MonoBehaviour`. 

Недостатки:
- Большое количество классов при небольшом количестве видов. Прокси выгоден при большом количестве видов.
- Нужно быть внимательным с инициализацией типов. Прокси вызывает методы Start и Awake только один раз. Для любой логики, которая должна быть запущена после смены типа, нужно не только правильно инициализировать класс, но и сбросить любое состояние, не соответствующее `GameObject`. По этой причине хранить минимум состояний `MonoBehaviour`, желательно только сериализуемые (`SpriteRenderer` и т д), а все остальные состояния, такие как цвет, передавать в конструкторе обычному классу.
- Есть проблема наличия механизма позволяющего различать подтипы. В примере ниже, если нам нужно знать, является ли объект скелетом или зомби, нам нужно свойство, возвращающее `GoblinType`. 

```cs
public interface IGoblin
{
   void Attack(Unit unit);
   void Move(Vector2 direction);
   void Die();
}
```

```cs
public interface IGoblinEventMethods : IGoblin
{
   void Update();
   // if necessary LateUpdate, FixedUpdate and so on
}
```

```cs
public class GoblinProxy : MonoBehaviour, IGoblin
{
    [SerializeField] private Sprite goblinSprite;
    [SerializeField] private Sprite goblinZombieSprite;
    [SerializeField] private Sprite goblinSkeletonSprite;
    
    private IGoblinEventMethods _goblinImplementation;
    private SpriteRenderer _spriteRenderer;

    private void Awake()
    {
        _spriteRenderer = GetComponent<SpriteRenderer>();
        CreateGoblinType(GoblinType.Goblin);
    }

    void Update() => _goblinImplementation.Update();

    public void Attack(GoblinProxy goblinProxy) => _goblinImplementation.Attack(goblinProxy);

    public void Move(Vector2 direction) => _goblinImplementation.Move(direction);

    public void Die() => _goblinImplementation.Die();

    public void CreateGoblinType(GoblinType goblinType)
    {
        _goblinImplementation = goblinType switch
        {
            GoblinType.Goblin => CreateGoblin(),
            GoblinType.GoblinZombie => CreateGoblinZombie(),
            GoblinType.GoblinSkeleton => CreateGoblinSkeleton(),
            _ => throw new ArgumentOutOfRangeException(nameof(goblinType), goblinType, null)
        };
        
        return;

        Goblin CreateGoblin()
        {
            _spriteRenderer.sprite = goblinSprite;
            return new Goblin(_spriteRenderer);
        }
        
        GoblinSkeleton CreateGoblinSkeleton()
        {
            _spriteRenderer.sprite = goblinSkeletonSprite;
            return new GoblinSkeleton(_spriteRenderer);
        }

        GoblinZombie CreateGoblinZombie()
        {
            _spriteRenderer.sprite = goblinZombieSprite;
            return new GoblinZombie(_spriteRenderer);
        }
    }
}

```

```cs
public class Goblin : IGoblinEventMethods
{
   private readonly SpriteRenderer _spriteRenderer;

   public Goblin(SpriteRenderer spriteRenderer)
   {
      _spriteRenderer = spriteRenderer;
      _spriteRenderer.color = Color.green;
      Debug.Log("A new Goblin Has Been Created");
   }
   
   public void Attack(GoblinProxy goblinProxy) => Debug.Log("Inside Goblin Attack");

   public void Move(Vector2 direction) => Debug.Log("Inside Goblin Move");

   public void Die() => Debug.Log("Goblin is dying.");

   public void Update() => Debug.Log("Inside Goblin Update");
}
```

```cs 
public class GoblinZombie : IGoblinEventMethods
{
   private readonly SpriteRenderer _spriteRenderer;
   
   public GoblinZombie(SpriteRenderer spriteRenderer)
   {
      _spriteRenderer = spriteRenderer;
      _spriteRenderer.color = Color.red;
      Debug.Log("A new GoblinZombie Has Been Created");
   }
   
   public void Attack(GoblinProxy goblinProxy) => Debug.Log("Inside GoblinZombie Attack");

   public void Move(Vector2 direction) => Debug.Log("Inside GoblinZombie Move");

   public void Die() => Debug.Log("GoblinZombie is dying.");

   public void Update() => Debug.Log("Inside GoblinZombie Update");
}

public class GoblinSkeleton : IGoblinEventMethods
{
   private readonly SpriteRenderer _spriteRenderer;
   
   public GoblinSkeleton(SpriteRenderer spriteRenderer)
   {
      _spriteRenderer = spriteRenderer;
      _spriteRenderer.color = Color.gray;
      Debug.Log("A new GoblinSkeleton Has Been Created");
   }
   
   public void Attack(GoblinProxy goblinProxy) => Debug.Log("Inside GoblinSkeleton Attack");

   public void Move(Vector2 direction) => Debug.Log("Inside GoblinSkeleton Move");

   public void Die() => Debug.Log("GoblinSkeleton is dying.");

   public void Update() => Debug.Log("Inside GoblinSkeleton Update");
}
```

```cs
public class InputManager : MonoBehaviour
{
   [SerializeField] private GoblinProxy goblin;
   
   private void Update()
   {
      if (Keyboard.current.qKey.wasPressedThisFrame)
      {
         goblin.Die();
         goblin.CreateGoblinType(GoblinType.Goblin);
      }
      
      if (Keyboard.current.wKey.wasPressedThisFrame)
      {
         goblin.Die();
         goblin.CreateGoblinType(GoblinType.GoblinZombie);
      }
      
      if (Keyboard.current.eKey.wasPressedThisFrame)
      {
         goblin.Die();
         goblin.CreateGoblinType(GoblinType.GoblinSkeleton);
      }
      
      if (Keyboard.current.aKey.wasPressedThisFrame)
      {
         goblin.Attack(null);
      }
      
      if (Keyboard.current.sKey.wasPressedThisFrame)
      {
         goblin.Move(Vector2.zero);
      }
   }
}
```