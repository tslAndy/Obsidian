#behavioral
Определяет семейство алгоритмов, инкапсулирует каждый и делает их взаимозаменяемыми в зависимости от клиентов

## Применять когда
- Много взаимосвязанных классов отличаются только поведением. Стратегия предоставляет способ сконфигурировать класс с одним из многих поведений.
- Нужны разные варианты алгоритмов, например более быстрые, но менее эффективные в плане памяти и наоборот
- Алгоритм использует данные, о которых клиенты не должны знать. Стратегия позволяет скрыть сложные структуры данных
- Класс определяет много поведений, и они выражены в классе как множественные условные переходы. Вместо это можно вынести условные конструкции в собственный класс Strategy

## Преимущества
- Поддержка семейств алгоритмов
- Альтернатива субклассированию. Если оно используется только для переопределния поведения, то можно использать стратегию.
- Позволяет избавиться от условных переходов.
- Выбор имплементации в реальном времени
- Большое число объектов. По возможности использовать общедоступные стратегии

## Реализация
- Стратегии можно передавать данные в интерфейсе Context, но при этом могут передаваться лишне данные, либо передавать ссылку на исходный объект.
- Если стратегия может быть определена на этапе компиляции и не изменится, можно использать дженерики, `Context<AStrategy> T.DoAlgo()`;

## В играх
```cs
public abstract class SpellStrategy: ScriptableObject
{
	public abstract void CastSpell(Transform origin);
}

[CreateAssetMenu(filename = "Shield Spell Strategy")]
public class ShieldStrategy: SpellStrategy
{
	public override void CastSpell(Transform origin)
	{
		public float duration = 10f;
		var shield = Instantiate(shieldPrefab, origi.position, Quaternion.identity, origin);
		Destroy(shield, duration);
	}
}

[CreateAssetMenu(filename = "Projectile Spawner Strategy")]
public class ProjectileSpawnerStrategy: SpellStrategy
{
	public GameObject projectilePrefab;
	public float speed = 10f;
	
	public override void CastSpell(Transform origin)
	{
		GameObject projectile = Instantiate(projectilePrefab, origin.position, Quaternion.identity);
		Rigidbody rb = projectile.GetComponent<Rigidbody>();
		rb.velocity = origin.forward * speed;
	}
}


[CreateAssetMenu(filename = "Projectile Spawn Strategy")]
public override void CastSpell(Transform origin)
{
	public float duration = 10f;
	var shield = Instantiate(shieldPrefab, origi.position, Quaternion.identity, origin);
	Destroy(shield, duration);
}
```

```cs
public class Hero : MonoBehaviour
{

	[SerializeField] SpellStrategy[] spells;

	private void CastSpell(int index) => spells[index].CastSpell(transform);

}
```
