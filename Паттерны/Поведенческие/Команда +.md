#behavioral
Инкапсулирует запрос, позволяя параметрищировать клиентов с разными запросами, и поддерживать отменяемые операции

## Применять когда
- Параметризировать объект действием для выполнения, как альтернатива - исполььзование callback
- Выполнять запросы в разное время. Объект команды имеет lifetime, который не зависит от основного объекта. Если получатель запроса может быть представлен адресно-независимым путем, то можно отправитель команды.
- Поддержка отмены
- Поддержка востановления после падения системы. Если хранить список операций, выполненых до падения, можно будет откатиться к состоянию перед ним

## Преимущества
- Отделяет объект, который вызывает операцию от объекта, который знает, как ее выполнить
- Команды это обычные объекты, которыми можно манипулировать и которые можно расширять
- Можно создавать композитные команды. Например команда, вызывающая несколько других

## Реализация
- При реализации списка команд для возможности отмены, команды, которые должны быть скопированы перед занесением в список, могут быть реализованы как прототипы.
- Для упрощения занесения информации (при отменяемых командах) можно использовать паттерн [[Мементо +]].
- Может хранить получателя (т. е. объект, который выполнит действие)
- Можно использовать Action, по сути представляют собой команды
- Можно определять макро-команды, в которые можно добавлять и удалять подкоманды

## Связанное
- Макро команды могут быть имплементированы как [[Компоновщик +]]
- [[Мементо +]] хранит состояние, нужное команде для операции отмены
- Копируемые перед занесением в историю команды как [[Прототип +]]


## В играх

```cs
public interface IEntity
{
	public void Attack();
	public void Spin();
	public void Jump();
}

public class Hero: MonoBehaviour, IEntity
{
	// implement attack, spin, jump
}
```

```cs
public interface ICommand
{
	public Task Execute();
}
```


```cs
public abstract class HeroCommand: ICommand
{
	protected readonly IEntity hero;

	protected HeroCommand(IEntity hero)
	{
		this.hero = hero;
	}

	public abstract Task Execute();

	public static T Create<T>(IEntity hero) where T: HeroCommand
	{
		return (T) System.Activator.CreateInstance(typeof(T), hero);
	}
}

public class AttackCommand : HeroCommand
{
    public AttackCommand(IEntity hero) : base(hero) { }

    public override async Task Execute()
    {
        hero.Attack();
        await Awaitable.WaitForSecondsAsync(hero.Animations.Attack());
        hero.Animations.Idle();
    }
}

public class SpinCommand : HeroCommand
{
    public SpinCommand(IEntity hero) : base(hero) { }

    public override async Task Execute()
    {
        hero.Spin();
        await Awaitable.WaitForSecondsAsync(hero.Animations.Spin());
        hero.Animations.Idle();
    }
}

```
```cs
public class CommandInvoker
{
    public async Task ExecuteCommand(List<ICommand> commands)
    {
        foreach (var command in commands)
        {
            await command.Execute();
        }
    }
}

public class CommandManager: MonoBehaviour
{
    public IEntity Entity;
    public ICommand singleCommand;
    public List<ICommand> commands = new();

    private readonly CommandInvoker commandInvoker = new();
    private bool isCommandExecuting;

    private void Start()
    {
        Entity = GetComponent<IEntity>();

        singleCommand = HeroCommand.Create<AttackCommand>(Entity);

        commands = new List<ICommand>
        {
            HeroCommand.Create<AttackCommand>(Entity),
            HeroCommand.Create<SpinCommand>(Entity),
            HeroCommand.Create<JumpCommand>(Entity)
        };
    }

    private async Task ExecuteCommand(List<ICommand> commands)
    {
        isCommandExecuting = true;
        await commandInvoker.ExecuteCommand(commands);
        isCommandExecuting = false;
    }

    private void Update()
    {
        if (isCommandExecuting) return;

        // if first button
        ExecuteCommand(new List<ICommand>{ singleCommand });

        // if second button
        ExecuteCommand(commands);

    }
}
```