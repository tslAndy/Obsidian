#behavioral
Определяет представление для грамматики данного языка

## Применять когда

Есть язык для интерпретации, и можно представить выражения в языке как абстрактные синтаксические деревья
Работает лучше всего когда
- Грамматика простая. Для сложной грамматики лучше использовать генераторы парсинга, которые не строят деревья, это уменьшит память и сэкономит время
- Эффективность не критична. Самые эффективные интерпретаторы обычно не имплементируются путем интерпетации дерева парсинга напрямую, сначала переводят в другую форму. Например, регулярные выражения часто формируются в машины состояний. Но даже в этом случае, translator может быть паттерном Интерпетатор, так что он еще применим.

Преимущества
- Легко изменять и расширять грамматику. Так как паттерн использует классы для представления грамматических правил, можно использовать наследование для изменения или расширения грамматики. Существующие выражения можно инкрементарно менять, и новые определять как вариации старых
- Реализация грамматики простая. Классы, определяющие узлы в дереве имеют похожие реализации.
- Сложная грамматика трудна для поддержки.
- Добавление новых способов интерпретации выражений. Если создается много способов интерпетации выражения, лучше использовать паттерн Посетитель для избежания изменения грамматических классов.

Реализация
- Интерпетатор не создает дерево
- Для создания новой интерпретации использовать [[Посетитель -]]
- Использование [[Легковес +]] для управляющих символов, так как их очень много

Связанное
- Абстрактное синтаксическое дерево это экземпляр Компоновщика
- Легковес для управляющих символов
- Итератор для обхода структуры
- Посетитель для определения поведения в каждом узле в дереве в одном класс