#behavioral
Определяет отношение один-ко-многим между объектами так, что при изменении состояния одного объекта, все зависимые узнают об этом и обновляютя.

## Применять когда
- Когда абстракция имеет два аспекта, один зависит от другого. Инкапсуляция этих объектов в отдельных объектах позволяет варьировать и переиспользовать их независимо.
- Когда изменения в одном объекте требует изменения в других, и вы не знаете, как много объектов должны быть изменены.
- Получатель не должен быть явно определен.

## Реализация
- В простейшем случае, в объекте можно хранить ссылку на наблюдателя, но при больших количествах объектов это будет дорого. Как вариант - использовать хэш таблицу, содержащую объект и его наблюдателя
- Вызывать обновление может либо сам объект, либо клиент, когда все изменения завершены
- ВАЖНО! При использовании подклассов объекта, переопределенные операции при наследовании в случае вызова base-метода вызовут обновление, и следующее изменение состояния не будет видно. Как вариант - использовать шаблонный метод в абстрактном классе Subject. Как вариант, это определить переопределяемый метод в базовом классе и вызов Notify после него, т. е.

```cs
DoSomething() // overrided in subclasses
Notify()
```

- Модели Push и Pull. В пуш-модели, объект посылает наблюдателям детализированную информацию об изменении, хотят они или нет. В пул-модели, посылает минимальное уведомление, и наблюдатель сам запращивает необходимую информацию
- Использование аспектов интереса. То есть наблюдатель уведомляется только при определенных обстоятельствах, напр. `Subject.Attach(Observer observer, Aspect interest)` и объект передает изменившийся аспект наблюдателю `Observer.Update(Subject subject, Aspect interest)`
- В случае сложных отношений между наблюдателями и объектами может потребовать отдельный объект, который будет управлять их взаимоотношениями. Это убирает необходимость в ссылках в объектах, определяет определенную стратегию обновления, и обновляет все зависимые наблюдатели по запросу. Это будет Change Manager, который является экземпляром [[Посредник -]], и он может быть [[Синглтон]].


## В играх

```cs
// BASIC
public class Collectible: MonoBehaviour
{
    [SerializeField] private int points;

    public static event Action<int> OnAnyCollected;

    void OnTriggerEnter(Collider other)
    {
        if (!other.CompareTag("Player")) return;
        OnAnyCollected?.Invoke(points);
        Destroy(gameObject);
    }
}


public class ScoreManager: MonoBehaviour
{
    TMP_Text scoreText;
    int currentScore;

    
    void Awake()
    {
        scoreText = GetComponent<TMP_Text>();
    }

    void OnEnable() => Collectible.OnAnyCollected += AddScore;
    void OnDisable() => Collectible.OnAnyCollected -= AddScore;

    private void AddScore(int points)
    {
        currentScore += points;
        scoreText.text = $"Score: {currentScore}";
    }
}
```


```cs
// GENERIC OBSERVER

using System;
using UnityEngine;
using UnityEngine.Events;

[Serializable]
public class Observer<T>
{
    [SerializeField] private T value;
    [SerializeField] private UnityEvent<T> onValueChanged;

    public T Value
    {
        get => value;
        set => Set(value);
    }

    public Observer(T value, UnityAction<T> callback = null)
    {
        this.value = value;
        onValueChanged = new UnityEvent<T>();
        if (callback != null)
            onValueChanged.AddListener((callback));
    }

    public void Set(T value)
    {
        if (Equals(this.value, value)) return;
        this.value = value;
        Invoke();
    }

    public void Invoke()
    {
        Debug.Log("Invoking");
        onValueChanged.Invoke(value);
    }

    public void AddListener(UnityAction<T> callback)
    {
        if (callback == null) return;
        if (onValueChanged == null) onValueChanged = new UnityEvent<T>();

        onValueChanged.AddListener(callback);
    }

    public void RemoveListener(UnityAction<T> callback)
    {
        if (callback == null) return;
        if (onValueChanged == null) return;

        onValueChanged.RemoveListener(callback);
    }

    public void RemoveAllListeners()
    {
        if (onValueChanged == null) return;

        onValueChanged.RemoveAllListeners();
    }

    public void Dispose()
    {
        RemoveAllListeners();
        onValueChanged = null;
        value = default;
    }
}



public class Hero: MonoBehaviour
{
    [SerializeField] public Observer<int> Health = new Observer<int>(100);

    void Start()
    {
        Health.Invoke();
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            Health.Value += 10;
        }
    }
}
```


```cs
// EVENT TOOLS

#if UNITY_EDITOR
using UnityEditor.Events;
#endif

[Serializable]
public class Observer<T>
{
    [SerializeField] private T value;
    [SerializeField] private UnityEvent<T> onValueChanged;

    public T Value
    {
        get => value;
        set => Set(value);
    }

    /*
        Observer<int> Health = new();
        int t = (int) Health;
    */
    public static implicit operator T(Observer<T> observer) => observer.value;

    public Observer(T value, UnityAction<T> callback = null)
    {
        this.value = value;
        onValueChanged = new UnityEvent<T>();
        if (callback != null)
            onValueChanged.AddListener((callback));
    }

    public void Set(T value)
    {
        if (Equals(this.value, value)) return;
        this.value = value;
        Invoke();
    }

    public void Invoke()
    {
        Debug.Log("Invoking");
        onValueChanged.Invoke(value);
    }

    public void AddListener(UnityAction<T> callback)
    {
        if (callback == null) return;
        if (onValueChanged == null) onValueChanged = new UnityEvent<T>();

#if UNITY_EDITOR
        UnityEventTools.AddPersistentListener(onValueChanged, callback);
#else
        onValueChanged.AddListener(callback);
#endif
    }

    public void RemoveListener(UnityAction<T> callback)
    {
        if (callback == null) return;
        if (onValueChanged == null) return;

#if UNITY_EDITOR
        UnityEventTools.RemovePersistentListener(onValueChanged, callback);
#else
        onValueChanged.RemoveListener(callback);
#endif
    }

    public void RemoveAllListeners()
    {
        if (onValueChanged == null) return;

#if UNITY_EDITOR
        FieldInfo fieldInfo = typeof(UnityEventBase).GetField("m_PersistentCalls", BindingFlags.Instance | BindingFlags.NonPublic);
        object value = fieldInfo.GetValue(onValueChanged);
        value.GetType().GetMethod("Clear").Invoke(value, null);
#else
        onValueChanged.RemoveAllListeners();
#endif
    }

    public void Dispose()
    {
        RemoveAllListeners();
        onValueChanged = null;
        value = default;
    }
}


public class HeroEditor : Editor
{
    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();

        Hero hero = (Hero)target;

        if (GUILayout.Button("Increase Health"))
        {
            hero.Health.Value += 10;
        }
        if (GUILayout.Button("Decrease Health"))
        {
            hero.Health.Value -= 10;
        }


        // Debugger is just example singleton class
        if (GUILayout.Button("Add Debugger"))
        {
            hero.Health.AddListener(Debugger.Instance.Debug);
        }

        if (GUILayout.Button("Remove Debugger"))
        {
            hero.Health.RemoveListener(Debugger.Instance.Debug);
        }
    }
}
```