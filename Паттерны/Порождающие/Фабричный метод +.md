#creational
Определяет интерфейс для создания объекта, но позволяет подклассам решать какой класс инстанциировать.

## Применять когда
- Класс заранее не знает, какой класс объекта нужно инстанциировать
- Класс хочет, чтобы его подклассы решали, какой класс инстанциировать
- Класс делегирует ответственность одному из подклассов помощников, и нужно локализовать информацию о том, какой из помощников является делегатом

## Преимущества
- Создание объекта в классе с фабричным методом более гибкое, чем напрямую.
- Соединяет параллельные иерархии классов.

## Реализация
- Может быть как абстрактным, так и предоставлять реализацию по умолчанию
- Может быть параметризованным, и подклассы могут при необходимости менять возвращаемый объект
- Можно использовать дженирики для уменьшения иерархии

## Использование в играх

Создание объектов без использования `switch` или `if`

```cs
class Knight
{
	[SerializaField] private string weaponType = "Sword";

	private IWeapon weapon;
	void Start()
	{
		switch(weaponType)
		{
			case Sword:
				Weapon = new Sword();
				break;
				
			case Bow:
				Weapon = new Bow();
				break;
		}
	}
}
```

```cs
public abstract class WeaponFactory: ScriptableObject
{
	public abstract IWeapon CreateWeapon();
}

[CreateAssetMenu(fileName = "WeaponFactory", menuName = "Weapon Factory/Sword")]
public class SwordFactory: WeaponFactory
{
	public override IWeapon CreateWeapon() => return new Sword();
}

[CreateAssetMenu(fileName = "WeaponFactory", menuName = "Weapon Factory/Bow")]
public class BowFactory: WeaponFactory
{
	public override IWeapon CreateWeapon() => return new Bow();
}

public interface IWeapon
{
	public void Attack();
	public static IWeapon CreateDefault() => new Sword();
}

public class Knight
{
	[SerializeField] WeaponFactory weaponFactory;
	private IWeapon weapon;

	void Start()
	{
		weapon = weaponFactory is null ? 
			IWeapon.CreateDefault():
			weaponFactory.CreateWeapon();

		weapon.Attack();
	}
}
```


## Связанное
- Фабричные методы обычно вызываются Шаблонными Методами