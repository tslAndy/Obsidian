#creational
Отделяет конструирование сложного объекта от его представления
так, что одинаковый процесс конструирования может давать разные представления

## Применять когда
- Алгоритм для создания сложного объекта не должен зависеть от частей, из которых он состоит и от того, как они соединяются
- Процесс конструирования должен допускать разные представления для конечного объекта

## Преимущества
- Позволяет варьировать внутреннее представление продукта
- Изолирует код конструирования и представления
- Дает контроль над процессом конструирования

## Реализация
- При необходимости взаимодействия с ранее созданными частями, строитель возвращает ссылку на созданный объект, которая будет снова передана в следующий шаг
- Методы по умолчанию определены как виртуальные
- Может строить [[Компоновщик +]]

Использование в играх - пошаговое конфигурирование в строго определенном порядке

```cs 
class EnemyBuilder
{
	private Enemy _enemy = new GameObject("Enemy").AddComponent<Enemy>();

	public void AddWeaponComponent() => ...;
	public void AddHealthComponent() => ...;
	public void AddAbilityComponent() => ...;
	// ...

	public Enemy Build()
	{
		// !!! IMPORTANT
		Enemy built = _enemy;
		_enemy = new GameObject("Enemy").AddComponent<Enemy>();


		return built;
	}
}


class EnemyDirector
{
	public Enemy Construct(EnemyBuilder builder)
	{
		builder.AddWeaponComponent();
		builder.AddHealthComponent();
		builder.AddAbilityComponent();

		return builder.Build();
	}
}

```


Можно сделать строителя на интерфейсах. Каждый предыдущий интерфейс указывает на следующий. Благодаря этому соблюдается нужный порядок выполнения операций

```cs
interface IEnemyBuilder { public IWeaponEnemyBuilder AddWeaponComponent(); }
interface IWeaponEnemyBuilder { public IHealthEnemyBuilder WeaponStrategy(); }
interface IHealthEnemyBuilder { public IFinalEnemyBuilder AddHealthComponent(); }
interface IFinalEnemyBuilder { public Enemy Build(); }


class EnemyBuilder: 
IEnemyBuilder, IWeaponEnemyBuilder, 
IHealthEnemyBuilder, IFinalEnemyBuilder
{
	private Enemy enemy = new GameObject().AddComponent<Enemy>();

	public IWeaponEnemyBuilder AddWeaponComponent()
	{
		enemy.gameObject.AddComponent<EnemyWeapon>();
		return this;
	}

	// other methods
}


// Здесь смешиваем Fluent Builder и обычный строитель
class EnemyDirector
{

	public Enemy Construct(IEnemyBuilder builder)
	{
		return builder
			.AddWeaponComponent()
			.AddWeaponStrategy()
			.AddHeatlthComponent()
			.Build();
	}
}

```