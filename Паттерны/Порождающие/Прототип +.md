#creational
Определяет вид объекта для создания путем использования прототипного экземпляра и создает новые копируя его

## Применять когда
- Система не должна завиеть от того, как ее продукты создаются
- Классы для инстанциирования определяются в реальном времени ИЛИ
- Нужно избежать построения иерархии, параллельной иерархии продуктов ИЛИ
- Когда экземпляры класса могут иметь одно из нескольких состояний

## Преимущества
- Скрывает конкретный класс продукта от клиента
- Добавление и удаление продуктов в рантайме
- Определение новых видов продуктов путем варьирования значений
- Уменьшает субклассирование
- Конфигурирование приложения с классами динамически.

## Реализация
- Когда количество прототипов не известно заранее, использовать менеджер прототипов
- При необходимости создать операцию Init для прототипов

## В играх
```cs
abstract class Monster
{
	public abstract Monster Clone();
}

class Ghost: Monster
{
	public int Health;
	public int Speed;

	public Ghost(int health, int speed)
	{
		Health = health;
		Speed = speed;
	}
	

	public override Clone() => new Ghost(Health, Speed);
}

public class Spawner
{
	private Monster prototype;
	public Spawner(Monster monster)
	{
		prototype = monster;
	}

	public Monster SpawnMonster() => prototype.Clone();
}
```


На делегатах

```cs
public delegate Monster SpawnDelegate();

public class Spawner
{
	private SpawnDelegate _spawnDelegate;
	public Spawner(SpawnDelegate spawnDelegate)
	{
		_spawnDelegate = spawnDelegate;
	}

	public Monster SpawnMonster() => _spawnDelegate();
}
```

На дженериках

```cs
public class Spawner<T> where T: Monster, new()
{
	public Monster SpawnMonster() => new T();
}

```