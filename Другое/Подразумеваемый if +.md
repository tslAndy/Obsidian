#other 

Единственное, что хуже, чем несколько вложенных операторов if в кодовой базе, это подразумеваемые операторы if, которые существуют только в голове программиста.

## Введение
Концепции цикломатической сложности и когнитивной сложности в информатике позволяют нам принимать решения о коде, который мы пишем, чтобы он был менее сложным и более понятным. Вот почему множественные операторы if, и, что еще хуже, вложенные операторы if, не одобряются. Они делают наш код более сложным для понимания и более жестким.

## Что такое подразумеваемые утверждения if?
Предположим, у нас есть метод в классе `Book`который возвращает количество страниц для этой книги:
```cs
public int GetNumberOfPages(){...}
```

Когда мы видим такой метод, мы ожидаем, что этот метод вернет количество страниц. Но это может быть не так. После вызова этого метода мы обнаруживаем, что результат равен -1.

Что означает -1? Что книга не существует? Вероятно, нет, потому что объект книги будет нулевым. Что первой страницы не существует? Первая страница — это часть страниц книги, так что, вероятно, это не она. Может быть, в `Book` есть объект `Pages`, который не был инициализирован?

В любом случае, мы не можем знать, пока не прочитаем документацию, если она существует, или не погрузимся в код `Book` и не попытаемся понять, что означает этот -1. Это пример подразумеваемого оператора if:`If the number of pages is -1 then ....`

Это утверждение существует только в голове программиста, который написал код. Все остальные должны погружаться в кодовую базу, чтобы понять это подразумеваемое утверждение if, и, что еще хуже, с этого момента, всякий раз, когда он читает код, относящийся к классу `Book`, должен держать некоторое пространство в своей голове занятым. В этом пространстве логическое выражение `If the number of pages is -1 then ....`всегда существует, и это означает, что в нашей голове остается меньше места для решения текущих проблем.

## Пример из реального мира
В одном из проектов был такой код:
```cs
Damage = FireDamage - FireDamage * FireResistancePercentage
```

Если кто-то прочитает это утверждение, он, вероятно, подумает, что оно подсчитывает размер ущерба: размер `Damage`будет равен полученному `FireDamage`, уменьшенному на размер `FireResistancePercentage`этого субъекта.

На самом деле, однако, это утверждение имело несколько подразумеваемых операторов if. После изучения кодовой базы я обнаружил, что `Damage`значение может быть отрицательным. Это подразумеваемый оператор if, который существует только в голове программиста, написавшего этот код:

Если `Damage` больше нуля, то `Damage` представляет собой повреждение, но если значение `Damage` меньше нуля, то `Damage` представляет собой исцеление.

Я обнаружил, что этот подразумеваемый оператор if был создан из-за другого подразумеваемого оператора if, существовавшего в кодовой базе:

Если `FireResistancePercentage` значение находится в диапазоне от 0 до 1, то `FireResistancePercentage` переменная представляет огнестойкость, но если значение `FireResistancePercentage` больше 1, то `FireResistancePercentage` переменная представляет огнестойкость, то есть ее значение равно значению `FireResistancePercentage` минус 1.

Но это еще не все. Кто-то, читая это однострочное утверждение, должен задаться вопросом: Если переменная `Damage`может быть отрицательной, что насчет `FireDamage`? Может ли это тоже быть отрицательным? И что насчет `FireResistancePercentage`, может ли это быть отрицательным?

- Если `FireDamage` имеет отрицательное значение, означает ли это исцеление от огня?
- Если `FireResistancePercentage` отрицательное, означает ли это слабость огня?
- А как насчет комбинации этих значений? Что, если `FireDamage`отрицательно, а `FireResistancePercentage`больше единицы, что тогда произойдет? Означает ли это, что существо, получающее исцеление от огня, которое также имеет огненное сродство, в действительности получает урон от огня?
- А если `FireDamage`отрицательно и `FireResistancePercentage`тоже, что тогда происходит? Получает ли существо, получающее исцеление от огня, которое также имеет слабость к огню, больше исцеления от огня?

Решение всего вышеперечисленного на самом деле простое: переменная с именем `Damage` должна представлять повреждение, переменная с именем `Healing` должна представлять исцеление и т. д. Это будет означать, что утверждение:
```cs
Damage = FireDamage - FireDamage * FireResistancePercentage
```
на самом деле делает то, что говорит, и его смысл можно понять, просто прочитав его, не копаясь в кодовой базе.

## Простота отличается от удобства
Вся причина вышеприведенного утверждения была в том, что это проще. Вместо того, чтобы писать много кода, для каждой другой возможной ситуации, такой как исцеление, сродство к огню или слабость к огню, все было в одном утверждении.

Наличие кода, который существует только в чьей-то голове, не является меньшим количеством кода. Это тот же объем кода, но не записанный. Код, который не записан, все еще существует в голове кодера, и каждый раз, когда ему приходится писать код о повреждении, новый код или исправлять ошибку, ему приходится помнить все вышеперечисленное.