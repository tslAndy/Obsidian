#other 
Adaptive Compositional Evolutionary Development

Adaptive (A)
- Adaptive to Requirements - Адаптация к требованиям (R)
- Adapt to Context - Адаптация к контексту (C)

Compositional (C)
+ Narrow Responsibility - Узкая Ответственность (N)
+ Widen Applicability - Расширение применимости (W)
+ Reduce Required Effort - Уменьшение требуемых усилий (R)

Evolutionary (E)
+ Adapt design to this delivery - Адаптировать дизайн к этой поставке (T)
+ Adapt design to next delivery - Адаптировать дизайн к следующей поставке (N)

![[Pasted image 20240801113004.jpg]]

## Адаптивное развитие
Означает адаптацию дизайна (и процесса, если на то пошло) к конкретным требованиям (нуждам) и контексту программного проекта. Поскольку разные программные проекты имеют разные потребности и контексты, по моему мнению, не имеет смысла использовать фиксированный набор правил или доктрин для управления дизайном. Вы используете методы и инструменты, которые позволяют программному обеспечению и кодовой базе соответствовать вашим потребностям.

Быть адаптивным означает, что вы можете свободно смешивать парадигмы программирования (FP, OOP, DOP и т. д.) по своему усмотрению. Не думайте, что вы должны придерживаться определенной парадигмы — просто потому, что так «кажется чище». Мы не пишем ПО, чтобы следовать доктрине. Мы пишем ПО, чтобы решать проблемы.

Естественным следствием того, что потребности управляют дизайном и процессом, является снижение приоритета доктрины парадигмы программирования. Используйте доктрины как руководящие принципы, но отклоняйтесь от них, когда этого требуют ваши потребности. Фактически, когда дело доходит до классических доктрин ООП, вы можете выиграть, полностью проигнорировав их. Я расскажу об этом подробнее в разделе о композиционном дизайне.

Быть адаптивным также означает, что вы адаптируете дизайн и процесс к контексту программного обеспечения. Обычно контекст включает такие факторы, как:
- Размер кодовой базы
- Ожидаемый срок службы программного обеспечения
- Количество разработчиков, работающих над программным обеспечением
- Потенциальный доход от программного обеспечения
- Серьезность последствий ошибок в программном обеспечении
- и т. д.

Обычно, чем меньше кодовая база, тем короче срок службы и меньше разработчиков и т. д. - тем меньше "структуры" требуется в кодовой базе - то есть вы можете обойтись менее хорошо спроектированной кодовой базой. Напротив, чем больше кодовая база, тем дольше срок службы и больше разработчиков и т. д. - тем больше структуры вам понадобится, чтобы поддерживать постоянную постоянную разработку.

## Эволюционное развитие
Эволюционная разработка означает разделение разработки более крупной системы на множество последующих более мелких поставок. Внутренний дизайн кодовой базы адаптируется в первую очередь к потребностям текущей и, возможно, следующих одной или двух поставок.

Я стараюсь избегать проектирования для требований, которые будут слишком далеки в будущем, если только я не знаю наверняка, как будет выглядеть программное обеспечение в то время. Требования могут измениться по мере того, как я узнаю больше о том, как программное обеспечение работает на практике. Вам могут не понадобиться те функции, которые, как вы думали, вам понадобятся. Вот где классический принцип YAGNI (You Aren't Going to Need It) является полезным руководящим принципом.

Естественным следствием отсутствия проектирования на будущее является то, что, возможно, придется перестраивать дизайн программного обеспечения в соответствии с потребностями будущих релизов — когда до них доберетесь.

## Композиционный дизайн
Проектирование вашей кодовой базы, состоящей из небольших частей, которые могут быть объединены в более крупные структуры, что позволяет вам решать множество похожих проблем с помощью тех же компонентов. Методы композиционного дизайна существуют как в функциональном программировании (ФП), так и в объектно-ориентированном программировании (ООП).

В FP композиционный дизайн принимает форму функциональной композиции, то есть функций, которые составлены из других функций. Функциональная композиция обычно выполняется путем передачи одной функции второй функции, которая затем возвращает третью функцию в качестве результата. Эта третья функция вызывает первую функцию как часть своего кода. 

В объектно-ориентированном дизайне часто менее очевидно, как конструировать классы и объекты таким образом, чтобы с кодовой базой было легко работать. Кажется, нет никаких официальных руководств по ООП (которые являются частью официального канона ООП), которые действительно хорошо работают на практике. 

### Декомпозиционное расширение + композиционное сокращение
Распространенным аргументом против разделения кодовой базы на множество мелких компонентов является то, что кодовая база становится запутанной и в ней становится гораздо сложнее ориентироваться из-за всех дополнительных файлов, которые появляются в результате разделения.

Прежде всего, наличие большого количества файлов в кодовой базе не является большой проблемой, если вы используете современную IDE, такую ​​как IntelliJ IDEA. Современные IDE обладают функционалом, который позволяет легко ориентироваться даже в больших кодовых базах с большим количеством файлов.

Во-вторых, что обычно не получается слишком много файлов при использовании композиционного дизайна. На самом деле, часто получается меньшая, более элегантная кодовая база, чем в противном случае. Чтобы понять, почему, нам нужно рассмотреть два явления, которые происходят в композиционном дизайне:
- Декомпозиционное расширение
- Композиционное сокращение

Сначала, когда вы начинаете разлагать ваши большие компоненты на более мелкие компоненты, ваша кодовая база будет расширяться. Это декомпозиция расширения .

Позже, когда вы начнете иметь возможность составлять новый код, используя существующие компоненты, ваша кодовая база будет расти гораздо медленнее, чем если бы вы не проектировали ее для композиции. Это композиционное сокращение.

## Методы композиционного дизайна
Два основных принципа композиционного дизайна — «сужение ответственности» и «расширение применимости» компонентов. Однако в эти две основные категории вложены и другие принципы.
- **Узкая ответственность**
    - Разделение доменной логики от доменной логики
    - Разделение доменной логики от внедоменной логики
    - Отделите состояние от действия
    - Отделите действие от контекста
- **Расширить применимость**
    - Используйте более общие типы в методах интерфейса
    - Добавьте больше методов, соответствующих большему количеству типов
    - Проектирование для динамической компоновки (внедрение зависимостей)
    - Проектирование с учетом расширяемости
    - Проектирование для обеспечения подключаемости
    - Проектирование с учетом конфигурируемости
- **Уменьшить требуемые усилия**

## Узкая ответственность
Первый принцип композиционного проектирования — искать способы сузить ответственность текущих компонентов вашей системы. При сужении ответственности компонента вы обычно в конечном итоге разделяете большие классы или методы на несколько меньших классов или методов — каждый с более узкими обязанностями.

Сужая ответственность, вы часто можете увеличить вероятность того, что полученные классы или методы будут повторно использованы. Более высокая степень удобства использования, как правило, приводит к меньшей, менее подверженной ошибкам кодовой базе по мере роста функциональности проекта.

Сужение ответственности компонента также, как правило, упрощает тестирование, поскольку тестировать приходится меньше поведения (ответственности). Это также может облегчить создание экземпляра компонента в состоянии, необходимом для ваших тестов. Проще настроить компонент — другими словами.

Принцип узкой ответственности иногда называют также [[Single Responsibility Principle +]] , но это слишком строгая формулировка принципа. Как именно выглядит единое обязательство? Каковы его границы? Термин «узкий» передает ту же идею, но без ощущения абсолютизма.

Несколько способов сузить ответственность.
### Разделить доменную логику
Распространенный способ сузить ответственность компонента — разделить его доменную логику на несколько доменных логических компонентов. У вас может быть компонент, который выполняет и A, и B, но теперь вам нужна функциональность B из нового компонента C.

Так же называется вертикальным разделением. Это происходит из-за тенденции рисовать архитектурные диаграммы с доменной логикой, наложенной поверх не доменных логических слоев. При разделении компонента доменной логики на такой диаграмме он станет двумя компонентами, расположенными в одном слое. Это будет выглядеть так, как будто больший компонент был «разделен вертикально» на два соседних компонента.

### Отделить доменную логику от недоменной
Другой распространенный способ сузить ответственность компонента — разделить его доменную логику от недоменной логики. Например, компонент, выполняющий доменно-специфическое вычисление над файлом, может также содержать логику, необходимую для загрузки файла в память. Такой компонент может иметь свою логику, разделенную на 2 компонента: один компонент выполняет доменно-специфическое вычисление, а другой компонент загружает файл в память (не-доменно-специфическая логика).

Компонент, загружающий файл в память, может быть повторно использован из другого доменно-специфического компонента, которому также необходимо работать с данными файла. Это так же называется горизонтальным разделением. Это происходит из-за тенденции рисовать диаграммы архитектуры с доменной логикой, наложенной поверх не-доменной логики. При разделении более крупного компонента на доменно-специфическую часть и не-доменно-специфическую часть в такой диаграмме он станет двумя компонентами, расположенными в разных слоях, доменно-специфический компонент поверх не-доменно-специфического компонента.

