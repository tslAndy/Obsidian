#other 
## Private
Переменные с модификатором private доступны другим экземплярам данного класса:

```cs
class Test
{
	private int secret = 7;

	public bool Equals(Test another) => this.secret == another.secret;
}
```

## Индексаторы могут использовать params параметры
```cs
public IEnumerable<string> this[params string[] keys]
{
   get { return keys.Select(key => internalDictionary[key]).AsEnumerable(); }
}
```

## Строковые литералы, определенные в вашем коде хранятся в единственном экземпляре
Многие разработчики думают, что следующий код:
```cs
if (x == "" || x == "y")
```
будет создавать пару строк каждый раз. Нет, не будет. C# как и многие другие языки программирования использует интернирование строк, и каждая литеральная строка используемая в вашем приложении кладется в специальный список (хеш таблицу), называемый пулом строк, откуда и берется ссылка на нее во время выполнения.

Если у вас есть классы, которые регулярно используют строки, рассмотрите возможность использования метода `String.Intern` для добавления их в пул строк.


## Переменные в методах могут иметь область видимости ограниченную фигурными скобками
```cs
private void MultipleScopes()
 {
   { var a = 1; Console.WriteLine(a); }
   { var b = 2; Console.WriteLine(a); }
 }
```

Данный код не компилируется из-за второй строчки, потому что она обращается к переменной, которая заключена в фигурные скобки. Такое разбиение метода на части фигурными скобками достаточно полезно, но гораздо лучшее решение — разделить метод, на меньшие, используя метод рефакторинга: выделение метода (extract method).

## Порядок, в котором вы описываете статические переменные, имеет значение
```cs
static class Program
 {
   private static int a = 5;
   private static int b = a;

   static void Main(string[] args)
    {
       Console.WriteLine(b);
    }
 }
```
Этот код будет печатать число 5. Если поменять местами описание переменных a и b, он будет печатать 0.

## Инициализатор полей
```cs
class ClassA
 {
   public string name = "Tim";
   public int age = 20;

   public ClassA()
    { }

   public ClassA(string name, int age)
    {
     this.name = name;
     this.age = age;
    }
  }
```

Код инициализации просто помещается в каждый из конструкторов.

```cs
class ClassA
  {
    public string name;
    public int age;

    public ClassA()
    {
      this.name = "Tim";
      this.age = 20;
      base..ctor();
    }

    public ClassA(string name, int age)
    {
      this.name = "Tim";
      this.age = 20;
      base..ctor();
      this.name = name;
      this.age = age;
    }
  }
```

Но если один конструктор вызывает другой, то инициализация помещается только в вызываемый конструктор…

```cs
class ClassA
 {
   public string name = "Tim";
   public int age = 20;

   public ClassA()
    { }

   public ClassA(string name, int age):this()
    {
     this.name = name;
     this.age = age;
    }
 }
```

что равносильно

```cs
class ClassA
  {
    public string name;
    public int age;

    public ClassA()
    {
      this.name = "Tim";
      this.age = 20;
      base..ctor();
    }

    public ClassA(string name, int age)
    {
      this..ctor();
      this.name = name;
      this.age = age;
    }
  }
```

## Структуры являются неизменяемыми, когда используются в коллекциях
```cs
struct Point
 {
   public int x;
   public int y;
 }

static void Main(string[] args)
 {
    var p = new Point();  p.x = 5; p.y = 9;
    var list = new List<Point>(10);
    list.Add(p);
    list[0].x = 90;//ошибка компиляции

    var array = new Point[10];
    array[0] = p;
    array[0].x = 90;//все ок
}
```

## Атрибуты у локальных функций
```cs
private static void Process(string?[] lines, string mark)
{
	foreach (var line in lines)
	{
		if (IsValid(line))
		{
			// ...
		}
	}

	bool IsValid([NonNullWhen(true)] string? line)
	{
		return !string.IsNullOrEmpty(line) && line.Length >= mark.Length;
	}
}
```

## Статические лямда-выражения
Смысл в том, чтобы сделать так, чтобы лямбды не могли захватить никакой контекст и локальные переменные:

```cs
static void SomeFunc(Func<int, int> f)
{
	Console.WriteLine(f(5));
}

static void Main(string[] args)
{
	int y1 = 10;
	const int y2 = 10;

	SomeFunc(i => i + y1); // 15
	SomeFunc(static i => i + y1); // error
	SomeFunc(static i => i + y2); // 15
}
```

## GetEnumerator как метод расширения
```cs
static class Program
{
	public static IEnumerator<T> GetEnumerator<T>(this ValueTuple<T, T, T, T, T> source)
	{
		yield return source.Item1;
		yield return source.Item2;
		yield return source.Item3;
		yield return source.Item4;
		yield return source.Item5;
	}
}
```

## Discard паттерн в параметрах лямбда-выражений и анонимных функций
Если не нужны параметры можно заменить на подчеркивание, тем самым проигнорировав:

```cs
Func<int, int, int> someFunc1 = (_, _) => {return 5;}
Func<int, int, int> someFunc2 = (int _, int _) => {return 5;}
Func<int, int, int> someFunc2 = delegate (int _, int _) => {return 5;}
```

## Pattern matching в if
```cs

// instead of
if (!(vehicle is Car)) { }

// like that
if (vehicle is not Car) { }
```

Плюс компактная запись проверок:
```cs

// old way
if (context is object && context.IsReachable && context.Length > 1) { }

// new way
if (context is {IsReachable: true, Length > 1}) { }
```

And, or, not и скобки для приоритетов:

```cs
if (context is {Length: > 0 and (< 10 or 25)})
```

## Pattern matching в switch
```cs
public decimal CalculateToll(object vehicle) =>
vehicle switch
{
	Car c => 2.00m,
	Taxi t => 3.50m,
	Bus b => 5.00m,
	{} => throw new ArgumentException(),
	null => throw new ArgumentException()
};

// with discard pattern
public decimal CalculateToll(object vehicle) =>
vehicle switch
{
	Car _ => 2.00m,
	Taxi _ => 3.50m,
	Bus _ => 5.00m,
	{} => throw new ArgumentException(),
	null => throw new ArgumentException()
};

// or without variables
public decimal CalculateToll(object vehicle) =>
vehicle switch
{
	Car => 2.00m,
	Taxi => 3.50m,
	Bus => 5.00m,
	{} => throw new ArgumentException(),
	null => throw new ArgumentException()
};

// complex expressions
public decimal CalculateToll(object vehicle) =>
vehicle switch
{
	Car {Passengers: 0} => 2.00m,
	Car {Passengers: 1} => 3.00m,
	Car {Passengers: 2} => 4.00m,
	Car => 5.00m,
};

// complex expressions
public decimal CalculateToll(object vehicle) =>
vehicle switch
{
	Bus b when (b.Riders / b.Capacity) < 0.5 => 1,
	Bus b when (b.Riders / b.Capacity) > 0.9 => 2,
};

// complex expressions
public decimal CalculateToll(object vehicle) =>
vehicle switch
{
	Car c => c.Passengers switch
	{
		0 => 1.00m;
		1 => 2.00m;
		2 => 3.00m;
		_ => 5.00m;
	}
};


// enum
private enum TimeBand
{
	MorningRush,
	Daytime,
	EveningRush,
	Overnight
}

private static TimeBand GetTimeBand(DateTime timeOfToll)
{
	timeOfToll.Hour switch
	{
		// logic pattern
		< 6 or > 19 => TimeBand.Overnight,
		
		// relational pattern
		< 10 => TimeBand.MorningRush,
		< 16 => TimeBand.DayTime,
		_ => TimeBand.EveningRush
	};
}

public static decimal PeakTimePremiumFull(DateTime timeOfToll, bool inbound) =>
    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch
{
    (true, TimeBand.MorningRush, true) => 2.00m,
    (true, TimeBand.MorningRush, false) => 1.00m,
    (true, TimeBand.Daytime, true) => 1.50m,
    (true, TimeBand.Daytime, false) => 1.50m,
    (true, TimeBand.EveningRush, true) => 1.00m,
    (true, TimeBand.EveningRush, false) => 2.00m,
    (true, TimeBand.Overnight, true) => 0.75m,
    (true, TimeBand.Overnight, false) => 0.75m,
    (false, TimeBand.MorningRush, true) => 1.00m,
    (false, TimeBand.MorningRush, false) => 1.00m,
    (false, TimeBand.Daytime, true) => 1.00m,
    (false, TimeBand.Daytime, false) => 1.00m,
    (false, TimeBand.EveningRush, true) => 1.00m,
    (false, TimeBand.EveningRush, false) => 1.00m,
    (false, TimeBand.Overnight, true) => 1.00m,
    (false, TimeBand.Overnight, false) => 1.00m,
};
```

## Оператор new
```cs
List<DateTime> datesList = new()
{
    new(2020, 10, 01),
    new(2020, 10, 02),
    new(2020, 10, 03),
    new(2020, 10, 04),
    new(2020, 10, 05)
};

Car[] cars = 
{
    new() {Passengers = 2},
    new() {Passengers = 3},
    new() {Passengers = 4}
};
```

## Target typed операторы ?? и ?:
```cs
int? result = b ? 0 : null; // nullable value type

Person person = student ?? customer; // Shared base type

```

## Переопределение возвращаемого типа методов
```cs
abstract class Animal
{
    public abstract Food GetFood();
    ...
}
class Tiger : Animal
{
    public override Meat GetFood() => ...;
}
```
В классе Tiger возвращаемое значение у метода GetFood переопределено с Food на Meat. Теперь это нормально если Meat является производным типом от Food.

## init-свойства
```cs
class Person {
    public string Name { get; init; }
    public string Company { get; init; }
    public Address CompanyAddress { get; init; }
}

Person employee = new () {
    Name = "Paul McCartney",
    Company = "High Technologies Center",
    CompanyAddress = new () {
        Country = "Russia",
        City = "Izhevsk",
        Line1 = "246, Karl Marx St."
    }
}

// or
public class Person
{
    private readonly string name;
       
    public string Name
    { 
        get => name; 
        init => name = (value ?? throw new ArgumentNullException(nameof(Name)));
    }
}
```

## Record
```cs
public record Person 
{
    public string LastName { get; }
    public string FirstName { get; }

    public Person(string first, string last) => (FirstName, LastName) = (first, last);
}

Person p1 = new ("Paul", "McCartney");
Person p2 = new ("Paul", "McCartney");

System.Console.WriteLine(p1 == p2);
```

Этот пример выведет в консоль true. Если бы Person был классом, то в консоль было бы выведено false, поскольку объекты сравниваются по ссылке: две ссылочные переменные равны только если ссылаются на один и тот же объект. Но это не так с записями. Записи сравниваются по значению всех их полей, включая приватные.

Поиграем с наследованием записей:
```cs
public record Teacher : Person
{
    public string Subject { get; }

    public Teacher(string first, string last, string sub)
        : base(first, last) => Subject = sub;
}
```

```cs
Person p = new("Paul", "McCartney");
Teacher t = new("Paul", "McCartney", "Programming");

System.Console.WriteLine(p == t);
```

Хотя запись Teacher и унаследована от Person, переменные p и t не будут равны, в консоль выведется false. Это потому что сравнение производится не только по всем полям записей, но и по типам, а типы тут явно разные.

И хотя сравнение наследуемых типов записей разрешено (но бессмысленно), сравнение вообще разных типов записей недопустимо в принципе:

```cs
public record Person
{
    public string LastName { get; }
    public string FirstName { get; }

    public Person(string first, string last) => (FirstName, LastName) = (first, last);
}

public record Person2
{
    public string LastName { get; }
    public string FirstName { get; }

    public Person2(string first, string last) => (FirstName, LastName) = (first, last);
}

// ...

Person p = new("Paul", "McCartney");
Person2 p2 = new("Paul", "McCartney");
System.Console.WriteLine(p == p2);    // ошибка компиляции
```

Ещё одна приятная особенность записей — ключевое слово with:
```cs
Person me = new("Steve", "Brown");
Person brother = me with { FirstName = "Paul" };
```

Сокращенное определение:
```cs
public record Person(string FirstName, string LastName);

public record Teacher(string FirstName, string LastName,
    string Subject)
    : Person(FirstName, LastName);

public sealed record Student(string FirstName,
    string LastName, int Level)
    : Person(FirstName, LastName);
```

Вы можете определить записи вот так вот сокращённо, а компилятор сам создаст за вас свойства и конструктор. Однако, у этой фичи есть дополнительная особенность — вы можете не только использовать сокращённую запись для определения свойств и конструктора, но одновременно можете добавить в запись свой метод:
```cs
public record Pet(string Name)
{
    public void ShredTheFurniture() =>
        Console.WriteLine("Shredding furniture");
}

public record Dog(string Name) : Pet(Name)
{
    public void WagTail() =>
        Console.WriteLine("It's tail wagging time");

    public override string ToString()
    {
        StringBuilder s = new();
        base.PrintMembers(s);
        return $"{s.ToString()} is a dog";
    }
}
```

Кроме всего уже сказанного, компилятор также умеет автоматически создавать деконструктор для записей:
```cs
var person = new Person("Bill", "Wagner");

var (first, last) = person; // Этот деконструктор создан автоматически
Console.WriteLine(first);
Console.WriteLine(last);
```

Во многим records похожи на обычные классы и структуры, например, они могут абстрактными, их также можно наследовать либо запрещать наследование с помощью оператора sealed. Тем не менее есть и ряд отличий. Рассмотрим некоторые основные отличия records от стандартных классов и структур.

При определении record компилятор генерирует метод Equals() для сравнения с другим объектом. При этом сравнение двух records производится на основе их значений.

```cs
var person1 = new Person("Tom");
var person2 = new Person("Tom");
Console.WriteLine(person1.Equals(person2)); // true
 
var user1 = new User("Tom");
var user2 = new User("Tom");
Console.WriteLine(user1.Equals(user2));     // false
 
public record Person
{
    public string Name { get; init; }
 
    public Person(string name) => Name = name;
}
public class User
{
    public string Name { get; init; }
    public User(string name) => Name = name;
}
```

В данном случае при сравнении двух объектов record Person мы увидим, что они равны, так как их значения (значения свойств Name) равны. Однако в случае с объектами класса User, которые имеют те же одинаковые значения мы увидим, что они не равны. Так как сравнение records производится по значению.

Records могут принимать данные для свойств через конструктор, и в этом случае мы можем сократить их определение. Например, пусть у нас есть следующая record Person:

```cs
public record Person
{
    public string Name { get; init; }
    public int Age { get; init; }
    public Person(string name, int age)
    {
        Name = name; Age = age;
    }
    public void Deconstruct(out string name, out int age) => (name, age) = (Name, Age);
}
```

Кроме конструктора здесь реализован деконструктор, который позволяет разложить объект Person на кортеж значений. И мы могли бы применить ее, например, следующим образом:

```cs
var person = new Person ("Tom", 37);
Console.WriteLine(person.Name); // Tom
 
var (personName, personAge) = person;
 
Console.WriteLine(personAge);     // 37
Console.WriteLine(personName);    // Tom
```

Выше определенную record Person можно сократить до позиционной record:
```cs
public record Person(string Name, int Age);
```

Это все определение типа. То есть мы говорим, что для типа Person будет создаваться конструктор, который принимает два параметра и присваивает их значения соответственно свойствам Name и Age, и что также автоматически будет создаваться деконструктор. Ее использование будет аналогично:

```cs
var person = new Person("Tom", 37);
Console.WriteLine(person); // Tom
 
var (personName, personAge) = person;
 
Console.WriteLine(personAge);     // 37
Console.WriteLine(personName);    // Tom
 
public record Person(string Name, int Age);
```
При необходимости также можно совмещать стандартное определение свойств и определение свойств через конструктор:

```cs
var person = new Person("Tom", 37) { Company = "Google"};
Console.WriteLine(person.Company); // Google
person.Company = "Microsoft";
Console.WriteLine(person.Company); // Microsoft
 
public record Person(string Name, int Age)
{
    public string Company { get; set; } = "";
}
```

Позиционные структуры для чтения. 
Следует отметить различие между позиционными классами и структурами record. Свойства класса record, которые устанавливаются через параметры конструктора, по умолчанию будут иметь модификатор init. То есть после установки их значений через конструктор, мы больше не сможем их изменить:

```cs
var person = new Person("Tom", 37);
person.Name = "Bob";    // ! Ошибка - значение нельзя изменить
 
public record Person(string Name, int Age);
```

Стоит отметить, что это относится только к тем свойствам, которые устанавливаются через конструктор.

Однако для позиционных структур record свойства будут иметь стандартные сеттеры, которые позволят изменять значения свойств:
```cs
var person = new Person("Tom", 37);
person.Name = "Bob";
Console.WriteLine(person.Name); // Bob - значение изменилось
// структура record
public record struct Person(string Name, int Age);
```
Чтобы для подобных свойств структуры record использовался модификатор init вместо обычных сеттеров, такую структуру надо определить с ключевым словом readonly:
```cs
var person = new Person("Tom", 37);
person.Name = "Bob";    // ! Ошибка - значение свойства нельзя изменить
 
// структура record доступна только для чтения
public readonly record struct Person(string Name, int Age);
```

Как и обычные классы record-классы могут наследоваться:
```cs
var tom = new Person("Tom", 37);
var bob = new Employee("Bob", 41, "Microsoft");
Console.WriteLine(tom); // Person {Name = Tom, Age = 37}
Console.WriteLine(bob); // Person {Name = Bob, Age = 41, Company = Microsoft}
 
public record Person(string Name, int Age);
public record Employee(string Name, int Age, string Company) : Person(Name, Age);
```

## Partial method
```cs
public partial class MyClass
{
    public partial int DoSomeWork(out string p);
}
public partial class MyClass
{
    public partial int DoSomeWork(out string p)
    {
        p = "test";
        System.Console.WriteLine("Partial method");
        return 5;
    }
}
```

## Module initializers
Есть три повода для внедрения этого функционала:  
- позволить библиотекам иметь какой-то способ единой одноразовой инициализации при загрузке с минимальным оверхэдом и без явной необходимости для пользователя что-то вызывать;
- существующий функционал статических конструкторов не очень подходит на эту роль, потому что райнтайм должен сначала выяснить: используется ли вообще класс со статическим конструктором (таковы правила), а это даёт измеримые задержки;
- генераторы кода должны иметь какую-то инициализационную логику, которую не надо явно вызывать.

```cs
using System.Runtime.CompilerServices;
class C
{
    [ModuleInitializer]
    internal static void M1()
    {
        // ...
    }
}
```

На метод накладываются некоторые ограничения:  
  

- он должен быть статическим;
- он не должен иметь параметров;
- он не должен ничего возвращать;
- он не должен работать с обобщениями (generics);
- он должен быть доступен из содержащего его модуля, то есть:  
    - он должен быть internal или public
    - он не должен быть локальным методом

А работает это так: как только компилятор находит все методы, помеченные атрибутом ModuleInitializer, он генерирует специальный код, который их все вызывает. Порядок вызова методов-инициализаторов указать нельзя, но он будет один и тот же при каждой компиляции.

## Индексы и диапазоны
Для начала, ввели новый тип под названием `Index` который представляет индекс элемента в массиве, строке или вашей собственной коллекции:
```cs
Index i0 = 2; // implicit conversion
```

У самого типа `Index` есть два свойства (зачем сделали свойства а не поля — тот еще вопрос):

- `Value`, то есть сколько элементов нужно отсчитать
- `IsFromEnd` — булевое значение, показывающее, нужно ли отсчитывать от _конца_ коллекции а не от начала

Структуру можно инициализировать просто вызвав конструктор:
```cs
Index i1 = new Index(0, false);
```

Код выше, как вы поняли, берет первый элемент с начала. А вот последний элемент (то есть нулевой, но с конца) можно взять вот так:
```cs
var i2 = ^0; // Index(0, true)
```

Следующий кусочек этого паззла — это тип `Range`, который представляет из себя линейный, направленный строго по возрастанию диапазон индексов, строго с шагом 1. Для него тоже введен новый синтаксис:

```cs
X..Y
```

Что означает «все элементы от X включительно до Y». При этом, включает ли диапазон значение с индексом `Y` или нет — _нельзя сказать_ не посмотрев на `Y`.

Итак, вот несколько примеров:
- `var a = i1..i2; // Range(i1, i2)` — полноценный диапазон с началом и концом
- `var b = i1..; // Range(i1, new Index(0, true));` — диапазон от `i1` и до конечного элемента
- `var c = ..i2; // Range(new Index(0, false), i2)` — диапазон от самого первого элемента и до индекса `i2`
- `var e = ..;` — вообще весь диапазон, то есть от первого и до последнего элемента
- `Range.ToEnd(2);` — эта и подобные статические функции — как раз то, что использует компилятор за кулисами; все это можно лицезреть, если открыть сборку в dotPeek, ilSpy или другом декомпиляторе

**Последний элемент включается только если он взят «с конца»**.
Представьте массив `x = {1, 2, 3}`. Если взять `x[0..2]` вы получите `{1, 2}`, а вот если взять `x[..2]` или например `x[..]`, вы получите `{1, 2, 3}`.

`Range` ведет себя в стандартных типах вот так:
- В массивах, он дает копию подмассива, прям копируя каждый элемент
- В строках происходит вызов `Substring()`. Строки в C# иммутабельные так что создается новая строка.
- На коллекциях можно вызывать `AsSpan()` передавая ему `Range`.
- В `Span` тоже можно засунуть `Range` — `Span.Slice()`, получив под-диапазон.

## Тонкости использования дефолтных методы интерфейсов
```cs
public interface IHuman
{
  string Name { get; set; }
    
  public void SayHello() 
  {
    Console.WriteLine($"Hello, I am {Name}");
  }
}

public class Human : IHuman
{
  public string Name { get;set; }
}
```

```cs
Human human = new Human() { Name = "John" };
human.SayHello(); // will not compile
```

 Вроде бы, валидный код. На самом деле нет — дело в том, что конкретный класс, хоть он и реализует тот или иной интерфейс, понятия не имеет о дефолтных методах этого интерфейса.

Почему, спросите вы? Потому, что вся соль этих методов в том, чтобы добавлять их **пост фактум**, когда вашим интерфейсом уже пользуются. А что если за это время класс `Human` обзавелся _собственным_ `SayHello()`? Правильно, будет конфликт.

Поэтому дизайнеры приняли такое решение: дефолтные методы доступны только через сам интерфейс, то есть требуется явное или неявное приведение типа к интерфейсу:

```cs
IHuman human = new Human() { Name = "John" };
human.SayHello();
((IHuman)new Human { … }).SayHello();
```

### Наследование интерфейсов
 Если два интерфейса реализуют одинаковый метод `Foo()` (с дефолтной реализацией), класс может реализовать оба этих интерфейса и получить две независимые реализации `Foo()`, обе из которых можно вызывать:
 ```cs
public interface IHuman
{
  string Name { get; set; }
  
  void SayHello() 
  {
    Console.WriteLine($"Hello, I am {Name}");
  }
}
public interface IFriendlyHuman : IHuman
{
  void SayHello()
  {
    Console.WriteLine(      $"Greeting, my name is {Name}");
  }
}
((IHuman)new Human()).SayHello();
// Hello, I am John
((IFriendlyHuman)new Human()).SayHello();
// Greeting, my name is John
```

Заметьте, что в коде выше `IFriendlyHuman.SayHello()` как бы должен override-ить `IHuman.SayHello()`, но этого не происходит! Что же нужно сделать чтобы вызов `SayHello()` стал действительно виртуальным? Нужно явно сказать об этом:

```cs
public interface IFriendlyHuman : IHuman
{
  void IHuman.SayHello()
  //   ↑↑↑↑↑↑
  {
    Console.WriteLine(      $"Greeting, my name is {Name}");
  }
}
```

Вот в этом случае вызов `SayHello()` на любом интерфейсе, будь то `IHuman` или `IFriendlyHuman` будет виртуальным и уже не важно, к какому из них вы скастовались:
```cs
((IHuman)new Human()).SayHello();
// Greeting, my name is John
((IFriendlyHuman)new Human()).SayHello();
// Greeting, my name is John
```

### Diamond Inheritance
Естественно, в ситуации когда вы можете иметь два «честных override-а» в двух интерфейсах-наследниках породит конфликт в случае, если вы попытаетесь реализовать их оба:
```cs
interface ITalk { void Greet(); }
interface IAmBritish : ITalk
{
  void ITalk.Greet() => WriteLine("Good day!");
}
interface IAmAmerican : ITalk
{
  void ITalk.Greet() => WriteLine("Howdy!");
}
class DualNational : IAmBritish, IAmAmerican {}
// Error CS8705 Interface member 'ITalk.Greet()' does not have a most specific implementation. Neither 'IAmBritish.ITalk.Greet()', nor 'IAmAmerican.ITalk.Greet()' are most specific.
```

Проблема тут в том, что компилятор не может найти «более специфичный» (то есть, ниже в иерархии наследования) интерфейс для использования и, в результате равнозначности, не поймет что нужно делать если кто-то вызовет какой-нибудь `IAmAmerican.Greet()` — ведь по идее нужно гулять по виртуальной таблице, а куда идти-то, если варианта два?

## Рекурсивные паттерны
```cs
var personsOrigin = person switch {
  { Name: "Dmitri" } => "Russia",
  { PhoneNumber: { Code: 46 } } => "Sweden",
  { Name: var name } => $"No idea where {name} lives"
};
```

## Интеграция с проверками на типы
Проперти-паттерны можно «поженить» с проверками на типы которые появились одним сишарпом ранее. Теперь можно проверить на тип, а потом еще и распаковать структуру:
```cs
IEnumerable<int> GetMainOfficeNumbers()
{
  foreach (var pn in numbers)
  {
    if (pn is ExtendedPhoneNumber { Office: "main" })
      yield return pn.Number;
  }
}
```

## Обобщённые атрибуты
Теперь нам позволяется объявлять атрибуты с использованием обобщений почти так же, как и в случае с классами и методами. Хоть мы и раньше могли передать тип в параметрах конструктора, никак не используя обобщения, теперь можно явно указать какие типы подлежат передаче через ограничитель типа where. А также не нужно каждый раз использовать оператор typeof.

Посмотрим, как это выглядит на примере простой реализации паттерна "декоратор". Определим сам обобщённый атрибут:

```cs
[AttributeUsage(AttributeTargets.Class)]
public class DecorateAttribute<T> : Attribute where T : class
{
    public Type DecoratorType{ get; set; }
    public DecorateAttribute()
    {
        DecoratorType = typeof(T);
    }
}
```

Далее реализуем как иерархию в соответствии с паттерном, так и фабрику для создания декорированных объектов. Особое внимание обратите на атрибут _Decorate_:

```cs
public interface IWorker
{
    public void Action();
}
public class LoggerDecorator : IWorker
{
    private IWorker _worker;
    public LoggerDecorator(IWorker worker)
    {
        _worker = worker;
    }
    public void Action()
    {
        Console.WriteLine("Log before");
        _worker.Action();
        Console.WriteLine("Log after");
    }
}
[Decorate<LoggerDecorator>]
public class SimpleWorker : IWorker
{
    public void Action()
    {
        Console.WriteLine("Working..");
    }
}

public static class WorkerFactory
{
    public static IWorker CreateWorker()
    {
        IWorker worker = new SimpleWorker();

        if (typeof(SimpleWorker)
            .GetCustomAttribute<DecorateAttribute<LoggerDecorator>>() != null)
        {
            worker = new LoggerDecorator(worker);
        }

        return worker;
    }
}
```

Пример работы:

```cs
var worker = WorkerFactory.CreateWorker();

worker.Action();
// Log before
// Working..
// Log after
```

Стоит отметить, что ограничения сняты не полностью – тип нужно указывать явно. Использовать параметр типа из класса, например, не получится:

```cs
public class GenericAttribute<T> : Attribute { }
public class GenericClass<T>
{
    [GenericAttribute<T>]
    //Error CS8968 'T': an attribute type argument cannot use type parameters
    public void Action()
    {
        // ....
    }
}
```

Может появиться вопрос: `GenericAttribute<int>` и `GenericAttribute<string>` это разные атрибуты, или несколько применений одного? В Microsoft решили, что это один и тот же. Из этого вытекает, что для многократного применения нужно будет установить свойство `AllowMultiple` в `true`. Модифицируем первоначальный пример:

```cs
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public class DecorateAttribute<T> : Attribute where T : class
{
    // ....
}
```

Теперь можно декорировать объект несколько раз:

```cs
[Decorate<LoggerDecorator>]
[Decorate<TimerDecorator>]
public class SimpleWorker : IWorker
{
    // ....
}
```

## Обобщённая математика
Сначала остановимся на двух универсальных последствиях нововведения:
- Статический метод (или свойство) интерфейса теперь может иметь модификатор _abstract_, обязывающий наследников реализовать соответствующий статический метод;
- Благодаря этому в интерфейсах теперь можно объявлять арифметические операторы.

Да, теперь у нас есть конструкция вида _static abstract_, что может показаться немного странным, но совсем лишенным смысла я бы это не назвал. Чтобы посмотреть на результат в деле, предлагаю немного надуманный пример со своей реализацией натурального числа, которое можно складывать и создавать из строки:

```cs
public interface IAddable<TLeft, TRight, TResult>
    where TLeft : IAddable<TLeft, TRight, TResult>
{
    static abstract TResult operator +(TLeft left, TRight right);
}
public interface IParsable<T> where T : IParsable<T>
{
    static abstract T Parse(string s);
}
public record Natural : IAddable<Natural, Natural, Natural>, IParsable<Natural>
{
    public int Value { get; init; } = 0;
    public static Natural Parse(string s)
    {
        return new() { Value = int.Parse(s) };
    }
    public static Natural operator +(Natural left, Natural right)
    {
        return new() { Value = left.Value + right.Value };
    }
}
```

Применить в деле заданные операции можно так:

```cs
var one = new Natural { Value = 1 };
var two = new Natural { Value = 2 };
var three = one + two;
Console.WriteLine(three);
// Natural { Value = 3 }

var parsed = Natural.Parse("42");
Console.WriteLine(parsed);
// Natural { Value = 42 }
```

В примере можно увидеть, что наследовать обобщённые интерфейсы для реализации статических абстрактных методов нужно с помощью рекурсивного шаблона [[Curiously Recurring Template +]] вида `Natural: IParsable<Natural>`. С ним надо быть повнимательнее, чтобы не перепутать параметр типа — `Natural : IParsable<OtherParsableType>`.

Более наглядно применение статических методов на параметрах типа можно увидеть на таком примере:

```cs
public IEnumerable<T> ParseCsvRow<T>(string content) where T : IParsable<T>
    => content.Split(',').Select(T.Parse);
// ....
var row = ParseCsvRow<Natural>("1,5,2");
Console.WriteLine(string.Join(' ', row.Select(x => x.Value)));
// 1 5 2
```

Заданием своей математики, естественно, дело не ограничивается. Был изменён механизм работы базовых типов: 20 из них реализуют соответствующие базовым операциям интерфейсы. Их можно посмотреть в [документации](https://learn.microsoft.com/en-us/dotnet/standard/generics/math).

Главным сценарием использования называется упрощение поддержки библиотек, в которых теперь не нужно перегружать одни и те же методы для работы со всеми возможными типами данных. Например, алгоритм сложения чисел в коллекции нам предлагают реализовать с использованием стандартного интерфейса _INumber_ вот так:

```cs
static T Sum<T>(IEnumerable<T> values)
    where T : INumber<T>
{
    T result = T.Zero;
    foreach (var value in values)
    {
        result += T.CreateChecked(value);
    }
    return result;
}
```

Метод будет работать как с натуральными, так и с действительными числами:

```cs
Console.WriteLine(Sum(new int[] { 1, 2, 3, 4, 5 }));
// 15

Console.WriteLine(Sum(new double[] { 0.5, 2.5, 3.0, 4.3, 3.2 }));
// 13.5
```

## Исходные строковые литералы
В C# у нас появилась возможность создавать "сырые" строки с помощью многократного (от трёх) написания кавычек. Принцип работы похож на буквальный идентификатор @, но есть два важных отличия:
- При разбиении на несколько строк все пробелы, предшествующие закрывающим кавычкам, будут удалены из итоговой строки;
- Появилась возможность буквально интерпретировать кавычки (и фигурные скобки при интерполяции).

Возьмём для примера формирование json строки внутри метода:
```cs
string GetJsonForecast(DateTime date, int temperature, string summary)
    => $$"""
    {
        "Date": "{{date.ToString("yyyy-MM-dd")}}", 
        "TemperatureCelsius": "{{temperature}}",
        "Summary": "{{summary}}",
        "Note": ""
    }
    """;
```

При выводе результата вызова получим строку в виде нормального json:
```cs
{
    "Date": "2022-09-16",
    "TemperatureCelsius": 10,
    "Summary": "Windy",
    "Note": ""
}
```

Синтаксические правила по работе с "сырыми" строками такие:
- Строка должна начинаться с 3-х и более кавычек. Таким образом, если нам надо будет разместить в литерале 3 кавычки подряд, то начинать и заканчивать строку нужно 4 символами и так далее;
- Аналогично это работает с интерполяцией, но уже от одного символа. Так, в примере выше было использовано два знака интерполяции, чтобы можно было записать фигурные скобки для описания структуры json;
- Исходная строка может быть однострочной. Тогда она должна содержать хотя бы один символ между кавычками;
- Исходную строку можно сделать многострочной. В этом случае открывающие и закрывающие кавычки должны занимать отдельные строки (добавлять на них текст не позволяется), а отступ у текста от края экрана не может быть меньше, чем у закрывающих кавычек.

## Перенос на новую строку при интерполяции
Ещё одно, на сей раз небольшое, улучшение при работе со строками: выражение внутри интерполяции теперь можно переносить на новую строчку:
```cs
Console.WriteLine(
    $"Roles in {department.Name} department are: {
        string.Join(", ", department.Employees
                                    .Where(x => x.Active)
                                    .Select(x => x.Role)
                                    .OrderBy(x => x)
                                    .Distinct())}");

// Roles in Security department are: Administrator, Manager, PowerUser
```

Приятная мелочь, если вдруг была потребность помещать длинную цепь операторов (вроде Linq) внутрь интерполяции. Хотя увлекаться переносами не стоит, устроить беспорядок тоже стало немного проще:
```cs
Console.WriteLine(
    $"Employee count is {
        department.Employees
                  .Where(x => x.Active)
                  .Count()} in the {department.Name} department");

// Employee count is 20 in the Security department
```

## Модификатор required
С модификатором _required_ появилась возможность обязать инициализировать поля и свойства внутри конструктора или инициализатора. Мотивации у такой возможности две.

Во-первых, при работе с большими иерархиями классов рано или поздно может скопиться boilerplate код, связанный с передачей большого количества данных в родительские конструкторы. Классический пример с фигурами:
```cs
class Point
{
    public int X { get; }
    public int Y { get; }
    public Point(int x, int y) 
    { 
        X = x;
        Y = y;
    }
}
// ....
class Textbox : Rectangle
{
    public string Text { get; }
    public Textbox(int x, int y, int width, int height, string text) 
        : base(x, y, width, height)
    {
        Text = text;
    }
}
```

Для краткости промежуточные ступени были пропущены, но это не мешает увидеть проблему: количество параметров увеличилось более, чем вдвое. Пример надуманный, но в сложных предметных областях положение дел может обстоять ещё хуже (особенно, если оно усугублено неудачным проектированием).

Однако если сделать конструктор без параметров, а свойствам _X_ и _Y_ добавить модификатор _required_, то это сместит обязательство по инициализации с разработчика типа на его пользователя. Перепишем пример:
```cs
class Point
{
    public required int X { get; set; }
    public required int Y { get; set; }
}
// ....
class Textbox : Rectangle
{
    public required string Text { get; set; }
}
```

Гарантией инициализации выступает факт наследования и теперь этим должен заниматься клиент:

```cs
var textbox = new Textbox() { Text = "button" };
// Error CS9035: Required member 'Point.X' be set in the object initializer
// or attribute constructor
// Error CS9035: Required member 'Point.Y' must be set in the object initializer
// or attribute constructor
// ....
```

Во-вторых, это будет полезно при использовании ORM, обязывающих иметь конструкторы без параметров, ведь, к примеру, раньше нельзя было обязать клиента проинициализировать поле с Id.

Все детали можно найти в [документации](https://learn.microsoft.com/dotnet/csharp/language-reference/keywords/required), я перечислю наиболее интересное:
- Можно отметить конструктор атрибутом _SetsRequiredMembers_, если есть гарантия, что все необходимые члены класса инициализируются в нём – тогда использовать инициализатор будет не обязательно;
- Если конструктор ссылается на другой, отмеченный таким атрибутом (через _this()_ или _base()_), то он также должен иметь этот атрибут;
- Пусть инициализация обязательна, её всё ещё можно произвести, присвоив _null_;

## Автоматическая инициализация структур
Теперь в конструкторах структур не обязательно инициализировать все члены структур – теперь, как и в случае с классами, они будут проинициализированы значениями по умолчанию при создании экземпляра структуры:
```cs
struct Particle
{
    public int X { get; set; }
    public int Y { get; set; }
    public double Angle { get; set; }
    public int Speed { get; set; }

    public Particle(int x, int y) 
    {
        X = x;
        Y = y;
    }
    public override string ToString()
    {
        return 
            $"{{ X = {X}, Y = {Y}, Angle = {Angle}, Speed = {Speed} }}";
    }
}

// ....

var particle = new Particle();
Console.WriteLine(particle);
// { X = 0, Y = 0, Angle = 0, Speed = 0 }
```

## Шаблоны списков
Очередное улучшение сопоставления шаблонов – появилась возможность использовать этот механизм по отношению к спискам и массивам:

- Для отдельных элементов можно использовать любой шаблон чтобы проверить соответствие каким-то условиям;
- Шаблон пустой переменной (`_`) соответствует одному элементу в коллекции;
- Шаблон диапазона (`..`) может соответствовать числу элементов от нуля и более. Использоваться может только один раз;
- Шаблон _var_ позволяет захватить один или несколько (с помощью шаблона диапазона) элементов коллекции. Тип можно указывать явно.

Используем все эти возможности для проверки коллекции через оператор _is_:
```cs
var collection = new int[] { 0, 2, 10, 5, 4 };
if (collection is [.., > 5, _, var even] && even % 2 == 0)
{
    Console.WriteLine(even);
    // 4
}
```

Естественно, шаблоны списков можно использовать и в выражениях _switch_. Там возможность захватывать элементы выглядит ещё более интересно. Например, теперь можно повеселиться и написать функцию проверки палиндрома таким образом:

```cs
bool IsPalindrome (string str) => str switch
{
    [] => true,
    [_] => true,
    [char first, .. string middle, char last]
         => first == last ? IsPalindrome (middle) : false
};

// ....

Console.WriteLine(IsPalindrome("civic"));
// True
Console.WriteLine(IsPalindrome("civil"));
// False
```

## Расширенное поле видимости nameof
Небольшое улучшение для оператора _nameof_: теперь он может захватывать имена параметров при использовании в атрибуте на методе или параметре:
```cs
[ScopedParameter(nameof(parameter))]
void Method(string parameter)
// ....
[ScopedParameter(nameof(T))]
void Method<T>()
// ....
void Method([ScopedParameter(nameof(parameter))] int parameter)
```

Достаточно полезное нововведение для nullable анализа. Теперь при ликвидации предупреждений не нужно полагаться на строки:

```cs
[return: NotNullIfNotNull(nameof(path))]
public string? GetEndpoint(string? path)
    => !string.IsNullOrEmpty(path) ? BaseUrl + path : null;
```

При использовании результата вызова такого метода ненужные предупреждения о null значении не появятся:

```cs
var url = GetEndpoint("api/monitoring");
var data = await RequestData(url);
```

## Модификатор доступа file
И ещё одно новое ключевое слово. В этот раз была добавлена область видимости типов, ограниченная файлом, в котором он объявлен. Обусловлено это нуждами кодогенерации, а именно – желанием избежать конфликтов имён.

Теперь, если объявить в разных файлах (но в одном пространстве имён) классы, добавив к первому модификатор _file_:
```cs
// Generated.cs
file class Canvas
{
    public void Render()
    {
        // ....
    }
}
```

А второй объявить как обычно:

```cs
// Canvas.cs
public class Canvas
{
    public void Draw()
    {
        // ....
    }
}
```