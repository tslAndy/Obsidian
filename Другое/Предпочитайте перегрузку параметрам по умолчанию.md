#other 
Почему использование перегруженных методов предпочтительнее использования методов с параметрами по умолчанию при построении библиотек.

## Введение
Создание C# DLL может быть очень полезным, если нам нужны классы, которые мы можем использовать в разных программах или предоставить эти классы кому-то другому для использования. Создавая библиотеку, мы упаковываем эти классы в файл DLL, а затем, ссылаясь на этот DLL, любая программа может использовать эти классы по своему усмотрению.

Пока наши методы сохраняют ту же сигнатуру, их можно использовать даже при изменении их внутренних реализаций. Таким образом, мы можем предоставлять обновления для нашей библиотеки, исправляя ошибки и баги, без необходимости для потребителя нашей библиотеки перекомпилировать свой проект.

Единственное, что должен сделать кто-то, когда он использует нашу библиотеку в своей программе и предоставил эту программу своим клиентам, это предоставить обновленную версию нашей DLL. Тогда его программа продолжит работать так же, и любые изменения/исправления в нашей библиотеке вступят в силу, без необходимости перекомпилировать и распространять новый двоичный код своего кода клиенту.

Однако есть небольшая деталь, когда мы используем методы с параметрами по умолчанию. Хотя его программа продолжит работать с нашей библиотекой, любые изменения значений наших параметров по умолчанию не вступят в силу, пока программа нашего потребителя не будет перекомпилирована с нашей новой версией нашей библиотеки.

## Методы с параметрами по умолчанию
```cs
public class Vehicle
{
    readonly int _maxPassengers;
    public int MaxPassengers => _maxPassengers;

    public Vehicle(int maxPassengers = 5)
    {
        _maxPassengers = maxPassengers;
    }
}
```

## Перегрузка метода
```cs
public class Vehicle
{
    readonly int _maxPassengers;
    public int MaxPassengers => _maxPassengers;

    public Vehicle()
    {
        _maxPassengers = 5;
    }

    public Vehicle(int maxPassengers)
    {
        _maxPassengers = maxPassengers;
    }
}
```

Но эти два фрагмента кода, хотя и кажутся эквивалентными, таковыми не являются. Если мы посмотрим на заниженный код, то сможем заметить разницу. 
Этот код:
```cs
Vehicle vehicleWithParameter = new();

public class Vehicle
{
        readonly int _maxPassengers;

        public Vehicle(int maxPassengers = 5)
        {
            _maxPassengers = maxPassengers;
        }
}
```

Превратится в этот:

```cs
internal class Program
{
    private static void <Main>$(string[] args)
    {
        Vehicle vehicle = new Vehicle(5);
    }
}

public class Vehicle
{
    private readonly int _maxPassengers;

    public Vehicle(int maxPassengers = 5)
    {
        _maxPassengers = maxPassengers;
    }
}
```

как мы видим, значение по умолчанию — это литеральная константа в вызывающем объекте. Если у нас есть класс транспортного средства в DLL, это создает проблему.

## Ссылка на нашу DLL
Используя параметр по умолчанию в нашей библиотеке, при компиляции кода наш метод будет иметь значение по умолчанию в качестве параметра.

В тот момент, когда мы изменим нашу библиотеку и скомпилируем ее, мы сможем предоставить новую библиотеку нашим клиентам, но любые изменения в параметре по умолчанию не вступят в силу, пока мы также не перекомпилируем и не распространим наш собственный код. Чтобы сделать это более понятным, рассмотрим следующую библиотеку:

```cs
namespace TestDefaultParameter
{
    public class Vehicle
    {
        readonly int _maxPassengers;
        public int MaxPassengers => _maxPassengers;

        public Vehicle(int maxPassengers = 5)
        {
            _maxPassengers = maxPassengers;
        }
    }
}
```

```cs
namespace TestOverload
{
    public class Vehicle
    {
        readonly int _maxPassengers;
        public int MaxPassengers => _maxPassengers;

        public Vehicle()
        {
            _maxPassengers = 5;
        }

        public Vehicle(int maxPassengers)
        {
            _maxPassengers = maxPassengers;
        }
    }
}
```

Мы компилируем этот код в DLL, а затем получаем следующую программу, которая его использует:

```cs
using TestDefaultParameter;
using TestOverload;

TestDefaultParameter.Vehicle vehicleWithParameter = new();
TestOverload.Vehicle vehicleWithOverload = new();

Console.WriteLine("Vehicle with parameter:" + vehicleWithParameter.MaxPassengers);
Console.WriteLine("Vehicle with overload:" + vehicleWithOverload.MaxPassengers);

Console.ReadLine();
```

Результат:

```
Vehicle with parameter:5
Vehicle with overload:5
```

Затем нам нужно изменить нашу библиотеку, поскольку мы решили, что лучшим значением по умолчанию будет 6:
```cs
namespace TestDefaultParameter
{
    public class Vehicle
    {
        readonly int _maxPassengers;
        public int MaxPassengers => _maxPassengers;

        public Vehicle(int maxPassengers = 6)
        {
            _maxPassengers = maxPassengers;
        }
    }
}
```

```cs
namespace TestOverload
{
    public class Vehicle
    {
        readonly int _maxPassengers;
        public int MaxPassengers => _maxPassengers;

        public Vehicle()
        {
            _maxPassengers = 6;
        }

        public Vehicle(int maxPassengers)
        {
            _maxPassengers = maxPassengers;
        }
    }
}
```

Мы компилируем DLL, и теперь наша скомпилированная программа по-прежнему может ее использовать, поскольку сигнатура метода не изменилась, но результат будет таким:

```
Vehicle with parameter:5
Vehicle with overload:6
```

Когда мы используем параметр по умолчанию в нашем методе, наше изменение не окажет никакого эффекта в уже скомпилированном коде. Единственный способ заставить наш код увидеть это изменение — перекомпилировать его и также распространить вместе с новой версией DLL.

