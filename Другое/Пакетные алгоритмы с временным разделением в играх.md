Разделение по времени — очень полезный метод повышения производительности пакетных алгоритмов (нескольких экземпляров одного и того же алгоритма): вместо того, чтобы запускать все экземпляры алгоритмов в одном кадре, распределите их по нескольким кадрам.

Например, если на уровне игры есть 100 NPC, вам, как правило, не нужно, чтобы каждый из них принимал решение в каждом кадре; если в каждом кадре будут принимать решения 50 NPC, это фактически снизит накладные расходы на принятие решений на 50%, 25 NPC — на 75%, а 20 NPC — на 80%.

Обратите внимание, что я сказал о временных срезах решений, а не о всей логике обновления NPC. В каждом кадре мы все равно хотим анимировать каждого NPC или, по крайней мере, тех, кто ближе и заметнее игроку, на основе **последнего решения** . Дополнительный слой анимации обычно может скрыть небольшую задержку в слое временных срезов решений.

## Пример
Пример, который я собираюсь использовать, — это простая логика, которая ориентирует NPC лицом к цели. Слой принятия решений каждого NPC вычисляет желаемую ориентацию для того, чтобы повернуться лицом к цели, а слой анимации пытается повернуть NPC так, чтобы они соответствовали желаемой ориентации, ограниченной максимальной угловой скоростью.

Сначала давайте посмотрим анимированную иллюстрацию того, как это может выглядеть, если этот алгоритм запускать для каждого NPC в каждом кадре (Обновить все).

Движущийся круг — это цель, черные указатели представляют NPC и их ориентацию, а красные индикаторы — желаемую ориентацию NPC.

![[update-all.gif]]
```cs
void NpcManager::UpdateFrame(float dt)
{
  for (Npc &npc : m_npcs)
  {
    npc.UpdateDesiredOrientation(target);
    npc.Animate(dt);
  }
}
 
void Npc::UpdateDesiredOrientation(const Object &target)
{
  m_desiredOrientation = LookAt(target);
}
 
void Npc::Animate(float dt)
{
  Rotation delta = 
    Diff(m_desiredOrientation, m_currentOrientation);
  delta = Limit(delta, m_maxAngularSpeed);
  m_currentOrientation = Apply(m_currentOrientation, delta);
}
```

Как упоминалось выше, обычно не нужно обновлять все решения NPC в одном кадре. Мы можем добиться элементарного временного разделения следующим образом:

```cs
void NpcManager::UpdateFrame(float dt)
{
  const unsigned kMaxUpdates = 4;
  unsigned npcUpdate = 0;
  while (npcUpdated < m_numNpcs && npcUpdated < kMaxUpdates)
  {
    m_aNpc[m_iNpcWalker].UpdateDesiredOrientation(target);
    m_iNpcWalker = (m_iNpcWalker + 1) % m_numNpc;
    ++npcUpdated;
  }
   
  for (Npc &npc : m_npcs)
  {
    npc.Animate(dt);
  }
}
```

Этот простой подход может быть достаточным. Однако иногда вам просто нужно больше контроля над синхронизацией ввода и вывода. Используя более сложную логику временного разделения, представленную ниже, вы можете выбрать различную синхронизацию ввода и вывода в соответствии с конкретными потребностями.

Прежде чем двигаться дальше, давайте рассмотрим терминологию, которая будет использоваться в этой статье.
- Завершение **batch**'а означает завершение выполнения логики принятия решения один раз для каждого NPC.
- **Job** представляет собой работу по запуску экземпляра логики принятия решений для NPC.
- **Input** — это данные, необходимые для выполнения задания.
- **Output** — это результаты работы после ее завершения.

## Временной срез
Вот шаги одного из способов квантования пакетных алгоритмов. Это, возможно, не самый лучший способ с точки зрения эффективности или использования памяти, но я нахожу его логически понятным и простым в поддержке (что также означает, что он хорош для презентационных целей). Так что если вам не нужна микрооптимизация, я бы не стал беспокоиться об этом слишком сильно.
1. Начните новый batch.
2. Выясните все задания, которые необходимо выполнить. Свяжите каждое задание с уникальным **ключом** , который можно использовать для вывода требуемых входных данных для задания.
3. Для каждого задания подготовьте экземпляр **параметров** задания , представляющий собой набор его ключа, входных и выходных данных.
4. Запуск и завершение максимального количества заданий на кадр.
5. В зависимости от времени вывода (подробнее об этом позже), **сохранить результаты** **задания** , включая вывод задания и связанный с ним ключ, поместив его в **кольцевой буфер** , представляющий **историю** результатов задания. Остальная часть игровой логики для запроса последних результатов по ключу.[](https://en.wikipedia.org/wiki/Circular_buffer)
6. После того, как все работы выполнены, партия закончена. Промыть и повторить.

Одним из преимуществ поиска вывода по ключу является то, что разные системы с временным разделением могут работать друг с другом просто отлично, даже если они ссылаются на вывод друг друга. Что касается системы, она ищет вывод из другой системы, используя ключ, а другая система возвращает последний действительный вывод, доступный для данного ключа. Что-то вроде мини-базы данных.

В нашем примере, поскольку каждая работа связана с NPC, кажется целесообразным использовать NPC в качестве отдельных ключей.

Далее следует классификация временных интервалов, основанная на времени чтения входных данных и сохранения выходных данных.

ПРИМЕЧАНИЕ: Использование слов «синхронный» и «асинхронный» здесь не имеет ничего общего с многопоточностью. Эти слова используются только для различения времени выполнения операций. Все, что представлено до раздела «Потоки» далее в этом посте, является однопоточным.
- **Асинхронный ввод** : ввод считывается заданием только при его запуске.
- **Синхронный ввод** : ввод считывается всеми заданиями при запуске нового batch.
- **Асинхронный вывод** : вывод задания сохраняется сразу после его завершения.
- **Синхронный вывод** : вывод всех заданий сохраняется после завершения batch.

Кольцевой буфер используется для того, чтобы остальная логика игры могла быть полностью независима от времени и предполагала, что вывод (запрошенный по ключу) является последним.

Смешивание и сопоставление различных таймингов ввода и вывода дает 4 комбинации. Асинхронный ввод/асинхронный вывод (AIAO), синхронный ввод/синхронный вывод (SISO), синхронный ввод/асинхронный вывод (SIAO) и асинхронный ввод/синхронный вывод (AISO). Давайте рассмотрим их по одному.

Для демонстрационных целей все анимированные иллюстрации ниже отражают настройку, в которой в каждом кадре запускается только одно задание. В реальной игре число должно быть установлено выше, если оно вносит неприемлемую задержку.

### Асинхронный ввод/Асинхронный вывод
Для нашего конкретного примера с NPC, поворачивающимися лицом к цели, комбинация AIAO, вероятно, имеет наибольший смысл. Входные данные считываются только при запуске задания, поэтому задание имеет последнее положение цели. Выходные данные сохраняются, как только задание завершается с результатами желаемой ориентации NPC, поэтому слой анимации NPC может немедленно отреагировать на последнюю желаемую ориентацию.

Вот анимированная иллюстрация того, как это могло бы выглядеть, если бы мы запускали задания с частотой 10 Гц (10 заданий NPC в секунду).
![[async-input-async-output-10hz.gif]]

А вот как это выглядит, если сделать на частоте 30 Гц.

![[async-input-async-output-30hz.gif]]
Вы можете видеть, что каждый NPC ждет начала своей работы, прежде чем получить последние данные о местоположении цели, и обновляет желаемую ориентацию сразу после завершения работы.
### Синхронный вход / Асинхронный выход
В случаях, когда асинхронный ввод от комбинации AIAO, как показано выше, вызывает нежелательное шатание, но при этом NPC по-прежнему должны реагировать сразу после завершения каждой из своих задач, мы можем использовать комбинацию SIAO.

Вот версия 10 Гц.
![[sync-input-async-output-10hz.gif]]

А вот версия 30 Гц.

![[sync-input-async-output-30hz.gif]]
Обратите внимание, что при запуске каждого задания в качестве входных данных используется та же целевая позиция, которая синхронизируется в начале каждой партии, тогда как выходные данные сохраняются для немедленной реакции NPC сразу после завершения каждого задания.

По сути, это то же самое, что и первая «базовая первая попытка» временного разделения, показанная выше.

### Синхронизация входного сигнала / Синхронизация выходного сигнала
Комбинацию SISO, вероятно, лучше всего объяснить, посмотрев сначала на анимированные иллюстрации. Ниже по порядку приведены версии этой комбинации на 10 Гц и 30 Гц.

![[sync-input-sync-output-10hz.gif]]![[sync-input-sync-output-30hz.gif]]
По сути, это «запаздывающая» версия самой первой анимированной иллюстрации, где каждый NPC полностью обновляется в каждом кадре. Весь ввод задания синхронизируется при запуске партии, а весь вывод сохраняется при завершении партии. По сути, это своего рода «двойной буфер», где последние результаты не отражаются, пока не будут завершены все задания в партии. По этой причине кольцевой буфер истории должен быть **как минимум в два раза больше** максимального размера партии для правильной работы комбинаций с **синхронизированным выводом**.

Комбинация SISO, вероятно, не идеальна для нашего конкретного примера. Однако для таких случаев, как обновление карт влияния, тепловых карт или любого вида анализа игрового пространства, комбинация SISO может оказаться полезной.'

### Асинхронный вход / синхронный выход
Честно говоря, я не могу придумать подходящий сценарий, чтобы оправдать использование комбинации AISO. Она включена сюда только для всеобъемлющих целей. Смотрите анимированные иллюстрации ниже в порядке версии 10 Гц и версии 30 Гц. Если вы можете придумать случай, когда комбинация AISO является лучшим выбором по сравнению с остальными тремя, пожалуйста, поделитесь своими идеями в комментариях или напишите мне по электронной почте. Мне бы очень хотелось узнать.
![[async-input-sync-output-10hz.gif]]
![[async-input-sync-output-30hz.gif]]
### Пример реализации
Теперь, когда мы рассмотрели все четыре комбинации временных интервалов, пришло время рассмотреть пример реализации, который делает именно то, что было показано выше.

Прежде чем перейти непосредственно к основной логике временного разделения, давайте сначала рассмотрим, как она встраивается в пример кода NPC, который мы видели ранее.

Класс утилиты timeslicer позволяет пользователям предоставлять функцию, которая устанавливает ключи для нового пакета (записывает в массив и возвращает новый размер пакета), функцию для установки ввода для задания (записывает на вход на основе ключа) и функцию, которая представляет собой логику для временного разделения (записывает на выход на основе ключа и ввода).
```cs
class NpcManager
{
  private:
     
    struct NpcJobInput
    {
      Point m_targetPos;
    };
     
    struct NpcJobOutput
    {
      Orientation m_desiredOrientation;
    };
     
    // timeslicing utility class
    Timeslicer
    <
      Npc*,         // key
      NpcJobInput,  // input
      NpcJobOutput, // output
      kMaxNpcs,     // max batch size
      false,        // sync input flag (false = async)
      false         // sync output flag (false = async)
    >
    m_npcTimeslicer;
 
  // ...other stuff
};
 
void NpcManager::Init()
{
  // set up keys for new batch
  auto newBatchFunc = 
    [this](Npc **aKey) unsigned
    {
      for (unsigned i = 0; i < m_numNpcs; ++i)
      {
        aKey[i] = GetNpc(i);
      }
      return m_numNpcs;
    };
   
  // set up input for job
  auto setUpInputFunc = 
    [this](Npc *pNpc, Input *pInput)->void
    {
      pInput->m_targetPos = GetTargetPosition(pNpc);
    }
 
  // logic to be timesliced
  auto jobFunc = 
    [this](Npc *pNpc, const Input &input, Output *pOutput)->void
    {
      pOutput->m_desiredOrientation = 
        LookAt(pNpc, input.m_targetPosition);
    };
 
  // initialize timeslicer
  m_npcTimeslicer.Init
  (
    newBatchFunc, 
    setUpInputFunc, 
    jobFunc
  );
}
 
void NpcManager::UpdateFrame(float dt)
{
  // timeslice decision logic
  m_timeslicer.Update(maxJobsPerFrame);
 
  // animate all NPCs based on latest decision results
  for (Npc &npc : m_npcs)
  {
    Output output;
    if (!m_timeSlicer.GetOutput(&npc, &output))
    {
      npc.SetDesiredOrientation(output.m_desiredOrientation);
    }
 
    npc.Animate(dt);
  }
}
```

Ниже представлен весь вспомогательный класс среза времени.

```cs
template
<
  typename Input, 
  typename Output, 
  typename Key, 
  unsigned kMaxBatchSize, 
  bool kSyncInput, 
  bool kSyncOutput
>
class Timeslicer
{
  private:
 
    struct JobParams
    {
      Key m_key;
      Input m_input;
      Output m_output;
    };
 
    struct JobResults
    {
      Key m_key;
      Output m_output;
    };
 
    // number of jobs in current batch
    unsigned m_batchSize;
 
    // keep track of jobs in current frame
    unsigned m_iJobBegin;
    unsigned m_iJobEnd;
 
    // required to start jobs
    JobParams m_aJobParams[kMaxBatchSize];
 
    // keep track of job results (statically allocated)
    static const unsigned kMaxHistorySize = 
      kSyncOutput
      ? 2 * kMaxBatchSize // more on this later
      : kMaxBatchSize;
    typedef RingBuffer<JobResults, kMaxHistorySize> History;
    History m_history;
 
    // set up keys for new batch
    // (number of keys = batch size = jobs per batch)
    typedef
      std::function<unsigned (Key *)>
      NewBatchFunc;
    NewBatchFunc m_newBatchFunc;
 
    // set up input for job
    typedef
      std::function<void (Key, Input *)>
      SetUpInputFunc;
    SetUpInputFunc m_setUpInputFunc;
 
    // logic to be timesliced
    // (takes key and input, writes output)
    typedef
      std::function<void (Key, const Input &, Output *)>
      JobFunc;
    JobFunc m_jobFunc;
 
 
  public:
 
    void Init
    (
      NewBatchFunc newBatchFunc, 
      SetUpInputFunc setUpInputFunc, 
      JobFunc jobFunc
    )
    {
      m_newBatchFunc = newBatchFunc;
      m_setUpInputFunc = setUpInputFunc;
      m_jobFunc = jobFunc;
 
      Reset();
    }
 
    void Reset()
    {
      m_batchSize = 0;
      m_iJobBegin = 0;
      m_iJobEnd = 0;
    }
 
    bool GetOutput(Key key, Output *pOutput) const
    {
      // iterate from newest history (last queued output)
      for (const JobResults &results : m_history.Reverse())
      {
        if (key == results.m_key)
        {
          *pOutput = results.m_output;
          return true;
        }
      }
 
      return false;
    }
 
    void Update(unsigned maxJobsPerUpdate)
    {
      TryStartNewBatch();
      StartJobs(maxJobsPerUpdate);
      FinishJobs();
    }
 
 
  private:
 
    void TryStartNewBatch()
    {
      if (m_iJobBegin == m_batchSize)
      {
        // synchronous output saved on batch finish
        if (kSyncOutput)
        {
          for (unsigned i = 0; i < m_batchSize; ++i)
          {
            const JobParams &params = m_aJobParams[i];
            SaveResults(params);
          }
        }
 
        Reset();
 
        Key aKey[kMaxBatchSize];
        m_batchSize = m_newBatchFunc(aKey);
 
        for (unsigned i = 0; i < m_batchSize; ++i)
        {
          JobParams &params = m_aJobParams[i];
          params.m_key = aKey[i];
 
          // synchronous input set up on new batch start
          if (kSyncInput)
          {
            m_setUpInputFunc(params.m_key, &params.m_input);
          }
        }
      }
    }
 
    void StartJobs(unsigned maxJobsPerUpdate)
    {
      unsigned numJobsStarted = 0;
      while (m_iJobEnd < m_batchSize
             && numJobsStarted < maxJobsPerUpdate)
      {
        JobParams &params = m_aJobParams[m_iJobEnd];
 
        // asynchronous input set up on job start
        if (!kSyncInput)
        {
          m_setUpInputFunc(params.m_key, &params.m_input);
        }
 
        m_jobFunc
        (
          params.m_key, 
          params.m_input, 
          &params.m_output
        );
 
        ++m_iJobEnd;
        ++numJobsStarted;
      }
    }
 
    void FinishJobs()
    {
      while (m_iJobBegin < m_iJobEnd)
      {
        const JobParams &params = 
          m_aJobParams[m_iJobBegin++];
 
        // asynchronous output saved on job finish
        if (!kSyncOutput)
        {
          SaveResults(params);
        }
      }
    }
 
    void SaveResults(const JobParams &params)
    {
      JobResults results;
      results.m_key = params.m_key;
      results.m_output = params.m_output;
 
      if (m_history.IsFull())
      {
        m_history.Dequeue();
      }
 
      m_history.Enqueue(results);
    }
};
```

### Потоки
Если ваш игровой движок допускает многопоточность, мы можем пойти на шаг дальше, разгрузив задания в потоки. Запуск задания сейчас создает поток, который запускает логику с временным срезом, а завершение задания сейчас ждет завершения потока. Нам нужно использовать блокировки чтения/записи, чтобы убедиться, что временной срез хорошо работает с остальной логикой игры. 

```cs
class Timeslicer
{
  // ...unchanged code omitted
 
  RwLock m_lock;
 
  struct JobParams
  {
    std::thread m_thread;
    Key m_key;
    Input m_input;
    Output m_output;
  };
 
  bool GetOutput(Key key, Output *pOutput) const
  {
    ReadAutoLock readLock(m_lock);
 
    // iterate from newest history (last queued output)
    for (const JobResults &results : m_history.Reverse())
    {
      if (key == results.m_key)
      {
        *pOutput = results.m_output;
        return true;
      }
    }
 
    return false;
  }
 
  void TryStartNewBatch()
  {
    WriteAutoLock writeLock(m_lock);
 
    if (m_iJobBegin == m_batchSize)
    {
      // synchronous output saved on batch finish
      if (kSyncOutput)
      {
        for (unsigned i = 0; i < m_batchSize; ++i)
        {
          const JobParams &params = m_aJobParams[i];
          SaveResults(params);
        }
      }
 
      Reset();
 
      Key aKey[kMaxBatchSize];
      m_batchSize = m_newBatchFunc(aKey);
 
      for (unsigned i = 0; i < m_batchSize; ++i)
      {
        JobParams &params = m_aJobParams[i];
        params.m_key = aKey[i];
 
        // synchronous input set up on new batch start
        if (kSyncInput)
        {
          m_setUpInputFunc(params.m_key, &params.m_input);
        }
      }
    }
  }
 
  void StartJobs(unsigned maxJobsPerUpdate)
  {
    WriteAutoLock writeLock(m_lock);
 
    unsigned numJobsStarted = 0;
    while (m_iJobEnd < m_batchSize
           && numJobsStarted < maxJobsPerUpdate)
    {
      JobParams &params = m_aJobParams[m_iJobEnd];
 
      // asynchronous input set up on job start
      if (!kSyncInput)
      {
        m_setUpInputFunc(params.m_key, &params.m_input);
      }
 
      params.m_thread = 
        std::thread([&params]()->void
        {
          m_jobFunc
          (
            params.m_key, 
            params.m_input, 
            &params.m_output
          );
        });
 
      ++m_iJobEnd;
      ++numJobsStarted;
    }
  }
 
  void FinishJobs()
  {
    WriteAutoLock writeLock(m_lock);
 
    while (m_iJobBegin < m_iJobEnd)
    {
      JobParams &params = m_aJobParams[m_iJobBegin++];
      params.m_thread.join();
 
      // asynchronous output saved on job finish
      if (!kSyncOutput)
      {
        SaveResults(params);
      }
    }
  }
};
```

Если ваша игра может позволить себе задержку на один кадр больше и вы не хотите, чтобы слайсер времени задерживал поток, вы можете немного подправить функцию обновления, при которой задания начинаются в конце обновления в текущем кадре и заканчиваются в начале обновления в следующем кадре.
```cs
void TimeSlicer::Update(unsigned maxJobsPerUpdate)
{
  FinishJobs();
  TryStartNewBatch();
  StartJobs(maxJobsPerUpdate);
}
```