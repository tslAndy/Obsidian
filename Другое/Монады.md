Базовым элементом каждой функциональной программы является Function. В типизированных языках каждая функция — это просто отображение между типом ее входного параметра и выходного параметра. Такой тип может быть аннотирован как `func: TypeA -> TypeB`.

C# — объектно-ориентированный язык, поэтому мы используем методы для объявления функций. Есть два способа определить метод, сопоставимый с `func`функцией выше. Я могу использовать статический метод:
```cs
static class Mapper
{
    static ClassB func(ClassA a) { ... }
}
```

… или метод экземпляра:

```cs
class ClassA
{
    // Instance method
    ClassB func() { ... }
}
```

Как нам составить более сложные рабочие процессы, программы и приложения из таких простых строительных блоков? Множество шаблонов как в ООП, так и в ФП-мире вращаются вокруг этого вопроса. И монады — один из ответов.

Пример кода будет о конференциях и докладчиках. Реализации методов не так уж и важны, просто внимательно следите за типами. Есть 4 класса (типа) и 3 метода (функции):
```cs
class Speaker
{
    Talk NextTalk() { ... }
}

class Talk
{
    Conference GetConference() { ... }
}

class Conference
{
    City GetCity() { ... }
}

class City { ... }
```

В настоящее время эти методы очень легко объединить в рабочий процесс:

```cs
static City NextTalkCity(Speaker speaker)
{
    Talk talk = speaker.NextTalk();
    Conference conf = talk.GetConference();
    City city = conf.GetCity();
    return city;
}
```

Поскольку тип возвращаемого значения предыдущего шага всегда соответствует типу входных данных следующего шага, мы можем записать его еще короче:

```cs
static City NextTalkCity(Speaker speaker)
{
    return
        speaker
        .NextTalk()
        .GetConference()
        .GetCity();
}
```
Но это не то, как выглядят настоящие кодовые базы, потому что на пути счастливой композиции есть множество осложнений. Давайте рассмотрим некоторые из них.

## Nulls
Любой экземпляр класса в C# может быть `null`. В примере выше я могу получить ошибки времени выполнения, если один из методов когда-либо вернет `null`управление.

Типизированное функциональное программирование всегда стремится явно указывать типы, поэтому я перепишу сигнатуры своих методов, чтобы обозначить возвращаемые типы как допускающие значение NULL:

```cs
class Speaker
{
    Talk? NextTalk() { ... }
}

class Talk
{
    Conference? GetConference() { ... }
}

class Conference
{
    City? GetCity() { ... }
}

class City { ... }
```

Теперь, составляя наш рабочий процесс, нам нужно позаботиться о `null`результатах:

```cs
static Nullable<City> NextTalkCity(Speaker speaker)
{
    Nullable<Talk> talk = speaker.NextTalk();
    if (talk == null) return null;

    Nullable<Conference> conf = talk.GetConference();
    if (conf == null) return null;

    Nullable<City> city = conf.GetCity();
    return city;
}
```

Это все тот же метод, но теперь он стал более шумным. Несмотря на то, что я использовал короткие возвраты и однострочники, его все равно стало сложнее читать.

Чтобы бороться с этой проблемой, умные разработчики языка придумали null propagation operator:

```cs
static Nullable<City> NextTalkCity(Speaker speaker)
{
    return
        speaker
        ?.NextTalk()
        ?.GetConference()
        ?.GetCity();
}
```

## Коллекции
Довольно часто функция возвращает коллекцию элементов, а не просто один элемент. В какой-то степени это обобщение случая `null`: с `Nullable<T>`мы можем получить 0 или 1 результат, тогда как с коллекцией мы можем получить от 0 до n результатов.

```cs
class Speaker
{
    List<Talk> GetTalks() { ... }
}

class Talk
{
    List<Conference> GetConferences() { ... }
}

class Conference
{
    List<City> GetCities() { ... }
}
```

Как бы мы объединили методы в один рабочий процесс? Традиционная версия выглядела бы так:
```cs
static List<City> AllCitiesToVisit(Speaker speaker)
{
    var result = new List<City>();

    foreach (Talk talk in speaker.GetTalks())
        foreach (Conference conf in talk.GetConferences())
            foreach (City city in conf.GetCities())
                result.Add(city);

    return result;
}
```

В качестве альтернативы разработчики языка C# изобрели методы расширения LINQ. Мы можем написать такой код:

```cs
static List<City> AllCitiesToVisit(Speaker speaker)
{
    return
        speaker
        .GetTalks()
        .SelectMany(talk => talk.GetConferences())
        .SelectMany(conf => conf.GetCities())
        .ToList();
}
```

Проделываем еще один трюк и отформатировать тот же код необычным образом:
```cs
static List<City> AllCitiesToVisit(Speaker speaker)
{
    return
        speaker
        .GetTalks()           .SelectMany(x => x
        .GetConferences()    ).SelectMany(x => x
        .GetCities()         ).ToList();
}
```

Теперь вы видите тот же исходный код слева, скомбинированный с небольшим количеством технического повторяющегося беспорядка справа. Давайте обсудим еще одно возможное осложнение.

## Асинхронные вызовы
А что, если нашим методам нужно получить доступ к какой-то удаленной базе данных или службе для получения результатов? Это должно быть показано в сигнатуре типа, и в C# `Task<T>`для этого есть:
```cs
class Speaker
{
    Task<Talk> NextTalk() { ... }
}

class Talk
{
    Task<Conference> GetConference() { ... }
}

class Conference
{
    Task<City> GetCity() { ... }
}
```

Мы вернемся к async-await позже, но первоначальный способ объединения `Task`методов на основе async-await заключался в использовании `ContinueWith` и `Unwrap` API:

```cs
static Task<City> NextTalkCity(Speaker speaker)
{
    return
        speaker
        .NextTalk()
        .ContinueWith(talk => talk.Result.GetConference())
        .Unwrap()
        .ContinueWith(conf => conf.Result.GetCity())
        .Unwrap();
}
```

Трудно читать, но применим трюк с форматированием:

```cs
static Task<City> NextTalkCity(Speaker speaker)
{
    return
        speaker
        .NextTalk()         .ContinueWith(x => x.Result
        .GetConference()   ).Unwrap().ContinueWith(x => x.Result
        .GetCity()         ).Unwrap();
}
```

Вы снова можете видеть, что слева представлен наш хорошо читаемый рабочий процесс, а справа — некоторый механический повторяющийся код соединения.

## Шаблон
Повторим рабочие процессы на основе `Nullable`-, `List`- и - `Task`:
```cs
static Nullable<City> NextTalkCity(Speaker speaker)
{
    return
        speaker               ?
        .NextTalk()           ?
        .GetConference()      ?
        .GetCity();
}

static List<City> AllCitiesToVisit(Speaker speaker)
{
    return
        speaker
        .GetTalks()            .SelectMany(x => x
        .GetConferences()     ).SelectMany(x => x
        .GetCities()          ).ToList();
}

static Task<City> NextTalkCity(Speaker speaker)
{
    return
        speaker
        .NextTalk()            .ContinueWith(x => x.Result
        .GetConference()      ).Unwrap().ContinueWith(x => x.Result
        .GetCity()            ).Unwrap();
}
```

Давайте попробуем обобщить этот подход. Учитывая некоторый общий тип контейнера `WorkflowThatReturns<T>`, у нас есть метод для объединения экземпляра такого рабочего процесса с функцией, которая принимает результат этого рабочего процесса и возвращает другой рабочий процесс обратно:

```cs
class WorkflowThatReturns<T>
{
    WorkflowThatReturns<U> AddStep(Func<T, WorkflowThatReturns<U>> step);
}
```

![[monad-bind.png]]

1. Экземпляр типа T находится в generic-контейнере
2. Мы вызываем AddStep с функцией, которая сопоставляет T к U, находящемся в другом контейнере
3. Мы получаем экземпляр U но в двух контейнерах
4. Два контейнера автоматически распаковываются в один контейнер, возвращаясь к исходной форме.
5. 1. Теперь мы готовы добавить еще один шаг

В следующем коде `NextTalk` возвращает первый экземпляр внутри контейнера:
```cs
WorkflowThatReturns<City> Workflow(Speaker speaker)
{
    return
        speaker
        .NextTalk()
        .AddStep(x => x.GetConference())
        .AddStep(x => x.GetCity());
}
```

Затем `AddStep`вызывается дважды для перемещения  к `Conference` и затем `City` в один и тот же контейнер.

![[monad-two-binds.png]]

## Монады
В терминах шарпа, монад это дженерик класс с двумя операциями - конструктором и связыванием:
```cs
class Monad<T> {
    Monad(T instance);
    Monad<U> Bind(Func<T, Monad<U>> f);
}
```

Конструктор используется чтобы поместить объект в контейнер, Bind используется чтобы заменить один объект в контейнере на другой.

Важно, что метод Bind возвращает `Monad<U>` а не просто U. Мы можем думать о Bind как о комбинации Map и Unwrap определенные через следующую сигнатуру:
```cs
class Monad<T> {
    Monad(T instance);
    Monad<U> Map(Function<T, U> f);
    static Monad<U> Unwrap(Monad<Monad<U>> nested);
}
```

## Maybe
```cs
public class Maybe<T> where T : class
{
    private readonly T value;

    public Maybe(T someValue)
    {
        if (someValue == null)
            throw new ArgumentNullException(nameof(someValue));
        this.value = someValue;
    }

    private Maybe()
    {
    }

    public Maybe<U> Bind<U>(Func<T, Maybe<U>> func) where U : class
    {
        return value != null ? func(value) : Maybe<U>.None();
    }

    public static Maybe<T> None() => new Maybe<T>();
}
```

Дано воображаемое соглашение о репозитории (которое что-то делает с клиентами и заказами):

```cs
public interface IMaybeAwareRepository
{
    Maybe<Customer> GetCustomer(int id);
    Maybe<Address> GetAddress(int id);
    Maybe<Order> GetOrder(int id);
}
```

Клиент может быть написан с использованием `Bind`композиции методов, без ветвлений, в свободном стиле:
```cs
Maybe<Shipper> shipperOfLastOrderOnCurrentAddress =
    repo.GetCustomer(customerId)
        .Bind(c => c.Address)
        .Bind(a => repo.GetAddress(a.Id))
        .Bind(a => a.LastOrder)
        .Bind(lo => repo.GetOrder(lo.Id))
        .Bind(o => o.Shipper);
```

## Task
В C# тип `Task<T>` используется для обозначения асинхронного вычисления, которое в конечном итоге вернет экземпляр `T`.

Хотя типичное использование `Task`в C# отличается от шаблона Monad, который мы обсуждали, все равно можно придумать `Future`класс со знакомой структурой:
\
```cs
public class Future<T>
{
    private readonly Task<T> instance;

    public Future(T instance)
    {
        this.instance = Task.FromResult(instance);
    }

    private Future(Task<T> instance)
    {
        this.instance = instance;
    }

    public Future<U> Bind<U>(Func<T, Future<U>> func)
    {
        var a = this.instance.ContinueWith(t => func(t.Result).instance).Unwrap();
        return new Future<U>(a);
    }

    public void OnComplete(Action<T> action)
    {
        this.instance.ContinueWith(t => action(t.Result));
    }
}
```

По сути, это просто оболочка, `Task`которая не добавляет особой ценности, но это полезная иллюстрация, поскольку теперь мы можем сделать так:

```cs
repository
    .LoadSpeaker()
    .Bind(speaker => speaker.NextTalk())
    .Bind(talk => talk.GetConference())
    .Bind(conference => conference.GetCity())
    .OnComplete(city => reservations.BookFlight(city));
```

## Непоследовательные рабочие процессы
До сих пор все составные рабочие процессы имели очень линейную, последовательную структуру: выход предыдущего шага всегда был входом для следующего шага. Этот фрагмент данных можно было отбросить после первого использования, поскольку он никогда не был нужен для последующих шагов:

![[linear-workflow.png]]Однако довольно часто это может быть не так. Шаг рабочего процесса может потребовать объединения данных из двух или более предыдущих шагов.

В приведенном выше примере `BookFlight`методу на самом деле могут понадобиться оба объекта, `Speaker` и `City`:
![[non-linear-workflow.png]]В этом случае нам пришлось бы использовать замыкание, чтобы сохранить `speaker`объект до тех пор, пока мы не получим `talk`:

```cs
repository
    .LoadSpeaker()
    .OnComplete(speaker =>
        speaker
            .NextTalk()
            .Bind(talk => talk.GetConference())
            .Bind(conference => conference.GetCity())
            .OnComplete(city => reservations.BookFlight(speaker, city))
        );
```

Если мы вернемся к использованию `Task` вместо нашего обычного `Future`, мы сможем написать:

```cs
var speaker = await repository.LoadSpeaker();
var talk = await speaker.NextTalk();
var conference = await talk.GetConference();
var city = await conference.GetCity();
await reservations.BookFlight(speaker, city);
```

Несмотря на то, что мы потеряли плавный синтаксис, по крайней мере блок имеет только один уровень, что упрощает навигацию.

## Законы монады
Есть несколько законов, которых конструктор `Bind`должен придерживаться, чтобы создать правильную монаду.

**Закон левой идентичности** гласит, что конструктор монад является нейтральной операцией: вы можете безопасно запустить его до `Bind`, и это не изменит результат вызова функции:

```cs
// Given
T value;
Func<T, Monad<U>> f;

// Then (== means both parts are equivalent)
new Monad<T>(value).Bind(f) == f(value)
```

Закон правой идентичности гласит, что если задано монадическое значение, то помещение содержащихся в нем данных в другую монаду того же типа и последующее  выполнение `Bind` не изменяет исходное значение:

```cs
// Given
Monad<T> monadicValue;

// Then (== means both parts are equivalent)
monadicValue.Bind(x => new Monad<T>(x)) == monadicValue
```

**Закон ассоциативности** означает, что порядок, в котором составлены `Bind` операции, не имеет значения:
```cs
// Given
Monad<T> m;
Func<T, Monad<U>> f;
Func<U, Monad<V>> g;

// Then (== means both parts are equivalent)
m.Bind(f).Bind(g) == m.Bind(a => f(a).Bind(g))
```