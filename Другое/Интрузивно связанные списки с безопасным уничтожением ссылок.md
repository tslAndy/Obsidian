Сначала давайте сделаем краткий обзор интрузивно связанных списков и сравним их с традиционными связанными списками.

```cs
template <typename T>
struct ListNode
{
  ListNode *prev, *next;
  T data;
};
```

Ссылка на предыдущий узел, ссылка на следующий узел и данные, просто. Однако эта реализация ломается, когда мы хотим иметь одни и те же данные в нескольких связанных списках. Это очень распространенная ситуация в игровом движке; например, игровые объекты хранятся в основном списке игровых объектов, а также в списке «подлежащих уничтожению», который содержит игровые объекты, помеченные для уничтожения в конце текущего кадра, так что нам не нужно проходить по (возможно, очень длинному) основному списку второй раз, чтобы проверить, какие игровые объекты помечены для уничтожения в конце каждого кадра.

Решение этой проблемы с использованием традиционного связанного списка заключается в том, чтобы сделать данные узла указателем, указывающим на реальные данные.

```cs
template <typename T>
{
  ListNode *prev, *next;
  T *data;
};
```

Это поднимает еще одну проблему: мы не можем выполнить удаление узла за постоянное время, просто передав указатель данных всем спискам, которые его содержат, потому что фактический объект данных и узлы не связаны. Кроме того, когда данные удаляются из памяти, мы должны знать, какие списки содержат указатели на эти данные, и заранее удалить соответствующие узлы. Слишком много бухгалтерии.

## Интрузивные списки
Как следует из названия, интрузивно связанные списки «интрузивно» встраивают ссылки в объекты данных, но мы рассмотрим подробности позже. Давайте быстро посмотрим, как будет выглядеть клиентский код, если мы используем интрузивно связанные списки. В коде ниже используются макросы для объявлений списков и узлов в качестве синтаксического сахара. Я объясню макросы позже.

```cs
// GameObject is the "host type" of the nodes
struct GameObject
{
  // intrusively linked list nodes
  LIST_LINK(GameObject) mainLink;
  LIST_LINK(GameObject) deadLink;
   
  string name;
  map<ComponentID, Component *> components;
 
  GameObject(string const &name)
    : name(name)
  { }
};
 
// two lists
LIST(GameObject, mainLink) mainList;
LIST(GameObject, deadLink) deadList;
 
// create game objects
GameObject *obj1 = new GameObject("object1");
GameObject *obj2 = new GameObject("object2");
GameObject *obj3 = new GameObject("object3");
 
// add game object to main lists
mainList.push_back(obj1);
mainList.push_back(obj2);
mainList.push_back(obj3);
 
// just add object 1 & 3 to dead list
// in reverse order
deadList.push_back(obj3);
deadList.push_back(obj1);
 
// use range-based for loop to delete objects
// no need to remove from main list
// because it is automatically handled
// as will be shown later
for (auto &obj : deadList)
  delete &obj;
```

## Интерфейс Link
Я поместил указатель на список-владелец внутри класса link, чтобы ссылка могла обновлять размер списка. Этот указатель на список также может пригодиться для отладки и различных утверждений. Его можно удалить, если он вам не нужен.
```cs
// forward declaration
template <typename T>
class List;
 
// forward declaration
template <typename T>
struct ListIterator;
 
// forward declaration
template <typename T>
struct ListConstIterator;
 
// list link interface
template <typename T>
struct ListLink
{
  public:
 
    ListLink(void);
    ~ListLink(void);
 
    // inserts link between two links
    void Link(ListLink *prev, ListLink *next);
     
    // unlinks link from list
    void Unlink(void);
 
  private:
 
    // these classes need to access private data members
    friend class List<T>;
    friend struct ListIterator<T>;
    friend struct ListConstIterator<T>;
 
    ListLink *m_prev, *m_next;
    List<T> *m_list;
};
```

## Интерфейс итератора
А вот интерфейс для итератора. Он довольно стандартный: операторы инкремента/декремента, операторы разыменования и операторы сравнения. Я решил скопировать смещение ссылки в итератор из списка, вместо того чтобы сохранять указатель обратно на список, поэтому не требуется косвенного обращения, когда требуется доступ к смещению ссылки. Тем не менее, наличие указателя обратно на список может быть полезным для отладки, поэтому вы можете выбрать выборочное включение такой информации с помощью определений конфигурации отладки.

```cs
// iterator interface
template <typename T>
struct ListIterator
{
  public:
 
    ListIterator
    (
      unsigned linkOffset = 0, 
      ListLink<T> *link = nullptr
    );
 
    T &operator* (void) const;
    T *operator->(void) const;
    ListIterator &operator++(void);
    ListIterator &operator--(void);
    ListIterator  operator++(int);
    ListIterator  operator--(int);
 
    bool operator==(const ListIterator &rhs) const;
    bool operator!=(const ListIterator &rhs) const;
 
  private:
   
    // list needs to access private data members      
    friend class List<T>;
 
    unsigned m_linkOffset;
    ListLink<T> *m_link;
};
```

## Интерфейс списка
последнее, но не менее важное: интерфейс для интрузивно связанного списка. Методы `typedef`s и `begin`/ `end`/ `cbegin`/ `cend` делают этот интерфейс совместимым с STL. Для простоты я опустил некоторые другие методы, такие как `pop_front`, `pop_back`, `insert_before`, и `insert_after`. Использование фиктивных ссылок head и tail значительно упрощает реализацию итераторов.

```cs
template <typename T>
class List
{
  public:
     
    // STL-compatible iterator typedefs
    typedef ListIterator<T> iterator;
    typedef ListConstIterator<T> const_iterator;
 
    List(unsigned linkOffset = 0);
    ~List(void);
 
    void push_back (T *obj);
    void push_front(T *obj);
 
    iterator erase(T *obj);
    iterator erase(iterator obj);
 
    void clear(void);
 
    unsigned size(void) const;
     
    // STL-compatible range methods
    iterator begin(void);
    iterator end  (void);
    const_iterator begin (void) const;
    const_iterator end   (void) const;
    const_iterator cbegin(void) const;
    const_iterator cend  (void) const;
 
  private:
 
    // these classes need to access private data members
    friend struct ListLink<T>;
    friend struct ListIterator<T>;
    friend struct ListConstIterator<T>;
 
    // memory offset of links into host type
    const unsigned k_linkOffset;
 
    // dummy links
    ListLink<T> m_head;
    ListLink<T> m_tail;
 
    unsigned m_size;
};
```

### Реализация

**Вспомогательные функции**
Для удобства ниже приведены две вспомогательные функции, которые выполняют преобразование между указателями типа хоста и указателями ссылок, используя смещение памяти.
```cs
template <typename T>
ListLink<T> *GetLinkFromObj(T *obj, unsigned linkOffset)
{
  return
    reinterpret_cast<ListLink<T> *>
    (
      reinterpret_cast<char *>(obj) + linkOffset
    );
}
 
template <typename T>
T *GetObjFromLink(ListLink<T> *link, unsigned linkOffset)
{
  return
    reinterpret_cast<T *>
    (
      reinterpret_cast<char *>(link) - linkOffset
    );
}
```

**Конструктор и деструктор ссылок**
Конструктор ссылок по сути инициализирует все значениями null, а деструктор ссылок обрабатывает удаление ссылки из списка владельцев.

```cs
template <typename T>
ListLink<T>::ListLink(void)
  : m_prev(nullptr)
  , m_next(nullptr)
  , m_list(nullptr)
{
  m_prev = m_next = this;
}
 
template <typename T>
ListLink<T>::~ListLink(void)
{
  Unlink();
}
```

**Методы ссылок**
Методы `Link` являются просто стандартной манипуляцией указателем двусвязного списка. Обратите внимание, что эти два метода обновляют размер списка. Обновление размера не может быть помещено в методы списка, поскольку список не имеет представления о том, когда будет вызван метод ссылки `Unlink` .

```cs
template <typename T>
void ListLink<T>::Link(ListLink *prev, ListLink *next)
{
  // update prev link
  prev->m_next = this;
  this->m_prev = prev;
 
  // update next link
  next->m_prev = this;
  this->m_next = next;
 
  // update list pointer
  m_list = next->m_list;
 
  // update list size
  ++m_list->m_size;
}
 
template <typename T>
void ListLink<T>::Unlink(void)
{
  if (m_list)
  {
    // update links
    m_prev->m_next = m_next;
    m_next->m_prev = m_prev;
 
    // update list size
    --m_list->m_size;
 
    // clean up pointers
    m_list = nullptr;
    m_prev = m_next = nullptr;
  }
}
```

**Конструктор списка**
Конструктор списка связывает фиктивные ссылки начала и конца списка, а деструктор списка очищает ссылки.

```cs
template <typename T>
List<T>::List(unsigned linkOffset)
  : k_linkOffset(linkOffset)
  , m_size(0)
{
  m_head.m_next = &m_tail;
  m_tail.m_prev = &m_head;
  m_head.m_list = m_tail.m_list = this;
}
 
template <typename T>
List<T>::~List(void)
{
  clear();
}
```

**Манипуляция со списком**
Методы `push`делегируют операцию push методу ссылки `Link`. Аналогично, пропущенные `pop`методы будут использовать метод ссылки `Unlink`. Метод `erase` возвращает итератор, указывающий на ссылку, следующую за стертой ссылкой, следуя соглашению STL.

```cs
template <typename T>
void List<T>::push_back(T *obj)
{
  push_back(GetLinkFromObj(obj, k_linkOffset));
}
 
template <typename T>
void List<T>::push_front(T *obj)
{
  push_front(GetLinkFromObj(obj, k_linkOffset));
}
 
template <typename T>
void List<T>::push_back(ListLink<T> *link)
{
  link->Link(m_tail.m_prev, &m_tail);
}
 
template <typename T>
void List<T>::push_front(ListLink<T> *link)
{
  link->Link(&m_head, m_head.m_next);
}
 
template <typename T>
typename List<T>::iterator List<T>::erase(T *obj)
{
  ListLink<T> *link = 
    GetLinkFromObj(obj, k_linkOffset);
 
  if (link == nullptr)
    return iterator(0, nullptr);
 
  iterator next(k_linkOffset, link->m_next);
  link->Unlink();
  return next;
}
 
template <typename T>
typename List<T>::iterator 
List<T>::erase(typename List<T>::iterator iter)
{
  ListLink<T> *link = iter.m_link;
 
  if (link == nullptr)
    return iterator(0, nullptr);
 
  iterator next(k_linkOffset, link->m_next);
  link->Unlink();
  return next;
}
 
template <typename T>
void List<T>::clear(void)
{
  while (m_head.m_next != &m_tail)
  {
    m_head.m_next->Unlink();
  }
}
```

**Итераторы списков**
Методы итераторов списка используют фиктивные ссылки head и tail для получения ожидаемого `begin`и `end`поведения. Методы `begin` должны возвращать итераторы, указывающие на первую ссылку, которая находится рядом с фиктивной ссылкой head; методы `end`должны возвращать итераторы, указывающие на ссылку one-past-last, которая является фиктивной ссылкой tail. Вот почему я сказал, что фиктивные ссылки удобны.

```cs
template <typename T>
typename List<T>::iterator List<T>::begin(void)
{
  return iterator(k_linkOffset, m_head.m_next);
}
 
template <typename T>
typename List<T>::iterator List<T>::end(void)
{
  return iterator(k_linkOffset, &m_tail);
}
 
template <typename T>
typename List<T>::const_iterator List<T>::begin(void) const
{
  return
    const_iterator
    (k_linkOffset, const_cast<ListLink<T> *>(m_head.m_next));
}
 
template <typename T>
typename List<T>::const_iterator List<T>::end(void) const
{
  return
    const_iterator
    (k_linkOffset, const_cast<ListLink<T> *>(&m_tail));
}
 
template <typename T>
typename List<T>::const_iterator List<T>::cbegin(void) const
{
  return
    const_iterator
    (k_linkOffset, const_cast<ListLink<T> *>(m_head.m_next));
}
 
template <typename T>
typename List<T>::const_iterator List<T>::cend(void) const
{
  return
    const_iterator
    (k_linkOffset, const_cast<ListLink<T> *>(&m_tail));
}
```

**Методы итератора**
Реализация итератора довольно тривиальна по сравнению с тем, что было показано до сих пор, поэтому я позволю коду говорить самому за себя. Реализация для `ListConstIterator`почти идентична, только с разным `const`ness.

```cs
template <typename T>
ListIterator<T>::ListIterator(unsigned linkOffset, ListLink<T> *link)
  : m_linkOffset(linkOffset)
  , m_link(link)
{ }
 
template <typename T>
T &ListIterator<T>::operator*(void) const
{
  return *GetObjFromLink(m_link, m_linkOffset);
}
 
template <typename T>
T *ListIterator<T>::operator->(void) const
{
  return GetObjFromLink(m_link, m_linkOffset);
}
 
template <typename T>
ListIterator<T> &ListIterator<T>::operator++(void)
{
  m_link = m_link->m_next;
  return *this;
}
 
template <typename T>
ListIterator<T> &ListIterator<T>::operator--(void)
{
  m_link = m_link->m_prev;
  return *this;
}
 
template <typename T>
ListIterator<T> ListIterator<T>::operator++(int)
{
  ListIterator copy = *this;
  ++*this;
  return copy;
}
 
template <typename T>
ListIterator<T> ListIterator<T>::operator--(int)
{
  ListIterator copy = *this;
  --*this;
  return copy;
}
 
template <typename T>
bool ListIterator<T>::operator==(const ListIterator &rhs) const
{
  return m_link == rhs.m_link;
}
 
template <typename T>
bool ListIterator<T>::operator!=(const ListIterator &rhs) const
{
  return !operator==(rhs);
}
```

### Вспомогательные макросы
Если бы мы попытались написать клиентский код, показанный выше (гораздо выше), используя вышеприведенную реализацию, то получилось бы что-то вроде этого:

```cs
// GameObject is the "host type" of the nodes
struct GameObject
{
  // intrusively linked list nodes
  ListNode<GameObject> mainLink;
  ListNode<GameObject> deadLink;
   
  string name;
  map<ComponentID, Component *> components;
 
  GameObject(string const &name)
    : name(name)
  { }
};
 
// two lists
List<GameObject> mainList(offsetof(GameObject, mainLink));
List<GameObject> deadlist(offsetof(GameObject, deadLink));
```

Здесь мы используем макрос `offsetof` для определения смещения памяти ссылок в тип хоста. Это работает, но каждое объявление списка включает в себя ввод типа хоста дважды и длинное выражение макроса. Поэтому здесь мы собираемся объявить шаблон вспомогательного класса и макрос для создания некоторого синтаксического сахара.

```cs
#define LIST(HostType, LinkName) \
  ListDecl<HostType, offsetof(HostType, LinkName)>
 
template <typename T, unsigned LinkOffset>
class ListDecl : public List<T>
{
  public:
    ListDecl(void) : List(LinkOffset) { }
};
```

Несмотря на то, что объявление ссылки не такое уж длинное, но ради единообразия вот макрос для объявления ссылки.

```cs
#define LIST_LINK(HostType) ListLink<HostType>
```

Вот и все. Хороший синтаксический сахар.

```cs
// GameObject is the "host type" of the nodes
struct GameObject
{
  // intrusively linked list nodes
  LIST_LINK(GameObject) mainLink;
  LIST_LINK(GameObject) deadLink;
   
  string name;
  map<ComponentID, Component *> components;
 
  GameObject(string const &name)
    : name(name)
  { }
};
 
// two lists
LIST(GameObject, mainLink) mainList;
LIST(GameObject, deadLink) deadList;
```

### Предостережения
**Круговая зависимость**
Использование макроса `offsetof` требует полного объявления типа хоста, а не просто прямого объявления. Это может привести к круговой зависимости. Если такого сценария нельзя избежать, единственным решением будет вернуться к использованию уродливого объявления списка в заголовочных файлах и «вручную» инициализировать смещение памяти ссылки в исходных файлах с помощью макроса `offsetof`.

**Конструкторы копирования**
Автоматически сгенерированный конструктор копирования типа хоста ссылки в свою очередь вызовет автоматически сгенерированный конструктор копирования класса ссылки, который скопирует точки `prev`и `next`. Это нежелательное поведение, поэтому мы должны сделать класс ссылки некопируемым, объявив конструктор копирования закрытым, или унаследовать от некопируемого класса mixin.