## Синтаксис инициализации коллекций
```cs
var list = new List<int> { 1, 2, 3 };
```
Возможность использования синтаксиса инициализации коллекции не ограничивается только классами из BCL. Он может быть использован с любым типом, удовлетворяющим следующим условиям:
- тип имплементирует интерфейс `IEnumerable`
- тип имеет метод с сигнатурой `void Add(T item)`

```cs
public class CustomList<T>: IEnumerable
{
    public IEnumerator GetEnumerator() => throw new NotImplementedException();
    public void Add(T item) => throw new NotImplementedException();
}
```
Мы можем добавить поддержку синтаксиса инициализации коллекции, определив `Add` как метод расширения:
```cs
public static class ExistingTypeExtensions
{
    public static void Add<T>(this ExistingType @this, T item) => throw new NotImplementedException();
}
```
Этот синтаксис также можно использовать для вставки элементов в поле-коллекцию без публичного сеттера:
```cs
class CustomType
{
    public List<string> CollectionField { get; private set; }  = new List<string>();
}

class Program
{
    static void Main(string[] args)
    {
        var obj = new CustomType
        {
            CollectionField =
            {
                "item1",
                "item2"
            }
        };
    }
}
```

Синтаксис инициализации коллекции полезен при инициализации коллекции известным числом элементов. Но что если мы хотим создать коллекцию с переменным числом элементов? Для этого есть менее известный синтаксис:

```cs
var obj = new CustomType
{
    CollectionField =
    {
        { existingItems }
    }
};
```

Такое возможно для типов, удовлетворяющих следующим условиям:
- тип имплементирует интерфейс `IEnumerable`
- тип имеет метод с сигнатурой `void Add(IEnumerable<T> items)`

```cs
public class CustomList<T>: IEnumerable
{
    public IEnumerator GetEnumerator() => throw new NotImplementedException();
    public void Add(IEnumerable<T> items) => throw new NotImplementedException();
}
```

К сожалению, массивы и коллекции из BCL не реализуют метод `void Add(IEnumerable<T> items)`, но мы можем изменить это, определив метод расширения для существующих типов коллекций:
```cs
public static class ListExtensions
{
    public static void Add<T>(this List<T> @this, IEnumerable<T> items) => @this.AddRange(items);
}
```

```cs
var obj = new CustomType
{
    CollectionField =
    {
        { existingItems.Where(x => /*Filter items*/).Select(x => /*Map items*/) }
    }
};
```

```cs
var obj = new CustomType
{
    CollectionField =
    {
        individualElement1,
        individualElement2,
        { list1.Where(x => /*Filter items*/).Select(x => /*Map items*/) },
        { list2.Where(x => /*Filter items*/).Select(x => /*Map items*/) },
    }
};
```

## Синтаксис инициализации словарей

```cs
var errorCodes = new Dictionary<int, string>
{
    [404] = "Page not Found",
    [302] = "Page moved, but left a forwarding address.",
    [500] = "The web server can't come out to play today."
};
```
Этот код эквивалентен следующему:
```cs
var errorCodes = new Dictionary<int, string>();
errorCodes[404] = "Page not Found";
errorCodes[302] = "Page moved, but left a forwarding address.";
errorCodes[500] = "The web server can't come out to play today.";
```

Лучшее в инициализации по индексу — это то, что она не ограничивается классом `Dictionary<T>` и может быть использована с любым другим типом, определившим индексатор:

```cs
class HttpHeaders
{
    public string this[string key]
    {
        get => throw new NotImplementedException();
        set => throw new NotImplementedException();
    }
}

class Program
{
    static void Main(string[] args)
    {
        var headers = new HttpHeaders
        {
            ["access-control-allow-origin"] = "*",
            ["cache-control"] = "max-age=315360000, public, immutable"
        };
    }
}
```

## Деконструкторы
Они позволяют декомпозировать кортеж в набор отдельных переменных:
```cs
var point = (5, 7);
// decomposing tuple into separated variables
var (x, y) = point;
```

Что эквивалентно следующему:
```cs
ValueTuple<int, int> point = new ValueTuple<int, int>(1, 4);int x = point.Item1;int y = point.Item2;
```

Этот синтаксис позволяет обменять значения двух переменных без явного объявления третьей:
```cs
int x = 5, y = 7;
//switch
(x, y) = (y,x);
```

Или использовать более краткий метод инициализации членов класса:
```cs
class Point
{
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y)  => (X, Y) = (x, y);
}
```

Именование полей кортежа:
```cs
public class UserService
{
    public (string FirstName, string Country) GetUser()
    {
        var firstName = "Josef";
        var country = "Sweden";
        return (firstName, country);
    }
}

[Fact]
public void ShouldReturnFirstNameAndCountry()
{
    var result = _sut.GetUser();

    result.FirstName.ShouldBe("Josef");
    result.Country.ShouldBe("Sweden");
}
```

Деконструкторы могут быть использованы не только с кортежами, но и с другими типами. Для использования деконструкции типа этот тип должен реализовывать метод, подчиняющийся следующим правилам:

- метод называется `Deconstruct`
- метод возвращает `void`
- все параметры метода имеют модификатор `out`

```cs
class Point
{
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y) => (X, Y) = (x, y);

    public void Deconstruct(out int x, out int y) => (x, y) = (X, Y);
}
```

```cs
var point = new Point(2, 4);
var (x, y) = point;
```

"Под капотом" превращается в следующее:
```cs
int x;
int y;
new Point(2, 4).Deconstruct(out x, out y);
```

Деконструкторы могут быть добавлены к типам с помощью методов расширения:
```cs
public static class PointExtensions
{
     public static void Deconstruct(this Point @this, out int x, out int y) => (x, y) = (@this.X, @this.Y);
}
```

Один из самых полезных примеров применения деконструкторов — это деконструкция `KeyValuePair<TKey, TValue>`, которая позволяет с легкостью получить доступ к ключу и значению во время итерирования по словарю:

```cs
foreach (var (key, value) in new Dictionary<int, string> { [1] = "val1", [2] = "val2" })
{
    //TODO: Do something
}
```

## Пользовательские awaitable типы
C# 5.0 (выпущен вместе с Visual Studio 2012) ввел механизм `async/await`, который стал переворотом в области асинхронного программирования. Прежде вызов асинхронного метода представлял собой запутанный код, особенно когда таких вызовов было несколько:

```cs
void DoSomething()
{
    DoSomethingAsync().ContinueWith((task1) => {
        if (task1.IsCompletedSuccessfully)
        {
            DoSomethingElse1Async(task1.Result).ContinueWith((task2) => {
                if (task2.IsCompletedSuccessfully)
                {
                    DoSomethingElse2Async(task2.Result).ContinueWith((task3) => {
                        //TODO: Do something
                    });
                }
            });
        }
    });
}

private Task<int> DoSomethingAsync() => throw new NotImplementedException();
private Task<int> DoSomethingElse1Async(int i) => throw new NotImplementedException();
private Task<int> DoSomethingElse2Async(int i) => throw new NotImplementedException();
```

Это может быть переписано намного красивее с использованием синтаксиса `async/await`:

```cs
async Task DoSomething()
{
    var res1 = await DoSomethingAsync();
    var res2 = await DoSomethingElse1Async(res1);
    await DoSomethingElse2Async(res2);
}
```

Это может прозвучать удивительно, но ключевое слово `await` не зарезервировано только под использование с типом `Task`. Оно может быть использовано с любым типом, который имеет метод `GetAwaiter`, возвращающий удовлетворяющий следующим требованиям тип:
- тип имплементирует интерфейс `System.Runtime.CompilerServices.INotifyCompletion` и реализует метод `void OnCompleted(Action continuation)`
- тип имеет свойство `IsCompleted` логического типа
- тип имеет метод `GetResult` без параметров

Для добавления поддержки ключевого слова `await` к пользовательскому типу мы должны определить метод `GetAwaiter`, возвращающий `TaskAwaiter<TResult>` или пользовательский тип, удовлетворяющий приведенным выше условиям:

```cs
class CustomAwaitable
{
    public CustomAwaiter GetAwaiter() => throw new NotImplementedException();
}

class CustomAwaiter: INotifyCompletion
{
    public void OnCompleted(Action continuation) => throw new NotImplementedException();

    public bool IsCompleted => throw new NotImplementedException();

    public void GetResult() => throw new NotImplementedException();
}
```

## Паттерн query expression
LINQ был разработан в первую очередь для работы с типами `IEnumerable`, `IEnumerable<T>` и `IQuerable<T>`, но он не ограничен только ими, и мы можем использовать его с любым типом, удовлетворяющим требованиям [паттерна query expression](https://github.com/dotnet/csharplang/blob/master/spec/expressions.md#the-query-expression-pattern). Полный набор сигнатур методов, используемых LINQ, таков:

```cs
class C
{
    public C<T> Cast<T>();
}

class C<T> : C
{
    public C<T> Where(Func<T,bool> predicate);

    public C<U> Select<U>(Func<T,U> selector);

    public C<V> SelectMany<U,V>(Func<T,C<U>> selector, Func<T,U,V> resultSelector);

    public C<V> Join<U,K,V>(C<U> inner, Func<T,K> outerKeySelector, Func<U,K> innerKeySelector, Func<T,U,V> resultSelector);

    public C<V> GroupJoin<U,K,V>(C<U> inner, Func<T,K> outerKeySelector, Func<U,K> innerKeySelector, Func<T,C<U>,V> resultSelector);

    public O<T> OrderBy<K>(Func<T,K> keySelector);

    public O<T> OrderByDescending<K>(Func<T,K> keySelector);

    public C<G<K,T>> GroupBy<K>(Func<T,K> keySelector);

    public C<G<K,E>> GroupBy<K,E>(Func<T,K> keySelector, Func<T,E> elementSelector);
}

class O<T> : C<T>
{
    public O<T> ThenBy<K>(Func<T,K> keySelector);

    public O<T> ThenByDescending<K>(Func<T,K> keySelector);
}

class G<K,T> : C<T>
{
    public K Key { get; }
}
```

Разумеется, мы не обязаны реализовывать все эти методы для того, чтобы использовать синтаксис `LINQ` с нашим пользовательским типом. Список обязательных операторов и методов `LINQ` для них можно посмотреть [здесь](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/query-expression-syntax-for-standard-query-operators). Объяснение того, как это сделать, можно найти в [[Understand monads with LINQ]]
