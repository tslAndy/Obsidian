#algs 
## Tail Recursion
Оптимизация рекурсивных вызовов, позволяющая избежать переполнения стэка. Это метод, при котором рекурсивные вызовы происходят последним действием в методе. 

```cs
public BigInt factorial(BigInt n)
{
  return accumulate(1, n);
}

private BigInt accumulate(BigInt current, BigInt n)
{
  return n == 0 ? current : accumulate(current * n, n - 1);
}
```

Концептуальное различие между первым и вторым примером заключается в том, что в первом случае вызов factorial(n - 1) не является хвостовым вызовом, поскольку это не конечное действие (мы умножаем результат вызова на текущее значение n), тогда как во втором случае мы всегда передаем дополнительный параметр, называемый «current», который служит аккумулятором и позволяет реализовать решение с хвостовой рекурсией.

## Зачем внедрять хвостовые вызовы
Огромное преимущество использования хвостовых вызовов заключается в том, что, поскольку они являются последними действиями в методе, текущий стековый кадр может быть повторно использован для следующего рекурсивного вызова — по сути, вам не нужно сохранять состояние, поскольку оно вам не понадобится после возврата из рекурсивного вызова. Это означает, что весь рекурсивный поток может быть выполнен в том же стековом кадре, что исключает возможные переполнения стека (и также ускоряет работу). Такой подход называется оптимизацией хвостового вызова, и в случае .NET или Java за его выполнение отвечает компилятор (путем выдачи правильных кодов операций IL).

## Оптимизация хвостового вызова в шарпе
К сожалению, оптимизации хвостовых вызовов не выполняются компилятором C# (хотя хвостовые вызовы полностью поддерживаются CLR, начиная с .NET 4.0). Вы можете легко убедиться в этом, запустив наш пример хвостового рекурсивного факториала и поместив точку останова внутрь метода «accumulate». Каждый раз, когда вы достигаете точки останова, вы можете видеть, что трассировка стека увеличивается в размере (Debug -> Windows -> Call Stack). 

## Trampoline
В случае, если оптимизацию хвостового вызова использовать нельзя, есть хорошо известный обходной путь с использованием техники, называемой «трамплининг», которую можно реализовать на любом языке, поддерживающем функции высшего порядка (C# — один из таких языков). Основная идея заключается в выполнении метода в цикле, тогда как сам метод может либо возвращать конечный результат, либо новый набор аргументов. Давайте рассмотрим, как можно изменить хвостовую рекурсивную реализацию факториала для использования трамплининга.

Сначала давайте определим тип возвращаемого значения для нашего действия «подпрыгивания» (которое должно выполняться в цикле):
```cs
public sealed class Bounce<T1, T2, TResult>
{
  public T1 Arg1 { get; private set; }
  public T2 Arg2 { get; private set; }
  public TResult Result { get; private set; }
  public bool HasResult { get; private set; }

  private Bounce() { }

  public static Bounce<T1, T2, TResult> Continue(T1 arg1, T2 arg2)
  {
    return new Bounce<T1, T2, TResult>() 
    { 
      Arg1 = arg1,
      Arg2 = arg2
    };
  }

  public static Bounce<T1, T2, TResult> End(TResult result)
  {
    return new Bounce<T1, T2, TResult>() 
    { 
      Result = result, 
      HasResult = true 
    };
  }
}
```

Как видите, мы можем либо передать следующие два аргумента (значения параметров `current` и `n` из примера с хвостовой рекурсией), либо передать конечный результат (в этом случае `HasResult` устанавливается в `true`, что сообщает вызывающему объекту о необходимости выйти из цикла).

## Реализация
```cs
public static class Trampoline
{
  public static TResult Start<T1, T2, TResult>(Func<T1, T2, Bounce<T1, T2, TResult>> action, 
    T1 arg1, T2 arg2)
  {
    TResult result = default(TResult);
    Bounce<T1, T2, TResult> bounce = Bounce<T1, T2, TResult>.Continue(arg1, arg2);

    while (true)
    {
      if (bounce.HasResult)
      {
        result = bounce.Result;
        break;
      }

      bounce = action(bounce.Arg1, bounce.Arg2);
    }

    return result;
  }
}
```

Реализация факториала теперь будет выглядеть следующим образом:

```cs
public BigInt factorial(BigInt n)
{
  return Trampoline.Start<BigInt, BigInt, BigInt>(iteration, 1, n);
}

private Bounce<BigInt, BigInt, BigInt> iteration(BigInt current, BigInt n)
{
  return n == 0 ? Bounce<BigInt, BigInt, BigInt>.End(current) : 
    Bounce<BigInt, BigInt, BigInt>.Continue(current * n, n - 1);
}
```