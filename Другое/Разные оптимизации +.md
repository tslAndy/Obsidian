## Убирать лишнюю работу

Код ниже пройдется по всем элементам коллекции, хотя по факту можно прекратить после 12 элементов, в этом случае придумать метод который будет обрываться после 12.  
```cs
collection.Count(predicate) > 12;
```

## Структуры вместо строк как ключи
Сравнение строк требует много ресурсов, эффективнее будет создать структуру, реализующую интерфейс `IEquatable<T>`:

```cs
public struct Key : IEquatable<Key>
{
    public string Type;
    public string Name;
 
    public Key(string type, string name)
    {
        this.Type = type;
        this.Name = name;
    }
 
    public override bool Equals(object obj)
    {
        if (obj is Key)
        {
            return this.Equals((Key)obj);
        }
        return false;
    }
 
    public bool Equals(Key other)
    {
        return this.Type.Equals(other.Type) && this.Name.Equals(other.Name);
    }
 
    public override int GetHashCode()
    {
        var h1 = this.Type.GetHashCode();
        var h2 = this.Name.GetHashCode();
        return (((h1 << 5) + h1) ^ h2);
    }
}
```

## Сравнение строк
При использовании `String.Equals()` and `String.Compare()` без аргумента `StringComparison` используется значение по умолчанию `StringComparison.CurrentCulture`. Во-первых, это может привести к неожиданному поведению, во-вторых это не слишком эффективно. При возможности стоит передавать `StringComparison.Ordinal` или `StringComparison.OrdinalIgnoreCase`, особенно в случае если используется константа:

```cs
string.Equals(“https”, uri.Schema)

string.Equals(“https”, uri.Schema, StringComparison.OrdinalIgnoreCase)
```

Второй метд поддерживает быстрое сравнение по 40 байт, сравнивая 4 байта int-сравнение если поддерживается `SIMD`.

## `String Split`
Аллоцирует массив `int` с индексами разделителей и массив строк для подстрок. Это тратит ресурсы сборщика мусора. Когда нужна одна подстрока из изначальной, лучше найти индекс по которому нужно разделить и потом вызвать `String.Split` по этому индексу. То же можно применить если известно ожидаемое количество строк, найти индексы разделителей и резать по ним. 

Метод `Split` принимает массив разделителей. Отдавать предпочтение `char[]`. Желательно не аллоцировать новый массив для разделителей при каждом вызове, т. е. когда мы вызываем `text.Split('X')` по факту мы вызываем `text.Split(new char[]{'​​​​X'}​​​​​​)`. Если мы знаем, сколько ожидаем строк, предоставить это в аргумент `count`, это позволит избежать недостаточного или избыточного аллоцирования. 

## `String.Replace`
При использовании одного символа использовать `char` а не `string`:
```cs
input = input.Replace("_", "-");

input = input.Replace('_', '-');
```

Если хочется пострадать хуйней, можно написать свой метод, который создаст свой `StringBuilder`, просканирует исходную строку сивол за символом, если надо добавит символ или его замену.

## LINQ evaluation
```cs
private static void RangeIEnumerable()
{
    var enumeration = Enumerable.Range(0, 1000);
    for (int i= 0; i < 10;  i++)
    {
        long count = enumerable.Max();
    }
}
 
private static void RangeList()
{
    var list = Enumerable.Range(0, 1000).ToList();
    for (int i = 0; i < 10; i++)
    {
        var count = list.Max();
    }
}
```

`LINQ` использует `IEnumerable`, поэтому при каждом вызове enumerable.Max() создается новая коллекция, поэтому метод со списком намного быстрее. 


Другая проблема в том, что реализации методов `LINQ` часто не оптимизированны для структур данных, что может вылиться в кважратичную сложность. 

Предположим, что у нас есть список важных векторов и список предоставленных векторов от пользователя, и хотим их отфильтровать. (10 итераций для упрощения измерений). 
```cs
HashSet<Vector3> importantVectorsHashSet = Enumerable.Range(0, 100).Select(x => x * Vector3.one).ToHashSet();
 
private static void ContainsIEnumerable(IEnumerable<Vector3> userProvidedVectors, IEnumerable<Vector3> importantVectors)
{
    for (int i = 0; i < 10; i++)
    {
        var important = userProvidedVectors.Where(v => importantVectors.Contains(v)).ToList();
    }
}
 
ContainsIEnumerable(userProvided, importantVectorsHashSet);
```

`importantVectors.Contains(v)` являтеся вызовом со сложностью O(N), так как перебирает все значения, несмотря на то, что в `HashSet` есть метод Contains сложностью O(1).

Данный код с линейной сложностью:
```cs
private static void ContainsHashSet(IEnumerable<Vector3> userProvidedVectors, HashSet<Vector3> importantVectors)
{
    for (int i = 0; i < 10; i++)
    {
        var important = userProvidedVectors.Where(v => importantVectors.Contains(v)).ToList();
    }
}
```

## List.Clear() вместо new List()
Очистка коллекции не обязательно освобождает занятую ей память, но при этом дешевле, чем создание новой

## Кэширование значений
Transform и множетсво других свойств можно кэшировать

## Вызов функции по таймеру
Если дорогостоящая функция не обязательно должна вызываться на каждом кадре, то ее можно запускать по таймеру

## Полиморфизм
Избегать субклассирования в местах, которые оптимизируются для кэша. 
- Это безопасно и просто. Вы точно знаете, с каким классом работаета, и, очевидно, все объекты одного размера. 
- Это быстро. Динамеческая диспетчеризация означает поиск метода в виртуальной таблице методов, стоимость отличается в зависимости от оборудования, но она есть в любом случае
- Это негибко. Если мы хотим, чтобы некоторые объекты имели свой стиль рендеринга или свои атаки и движения, виртуальные методы это хороший способ реализовать это. Использование одного метода с `switch` плохая идея.

**Используйте отдельный массив для каждого типа**:
Мы используем полиморфизм чтобы вызывать поведение у объектов, чей тип мы не знаем. Другими словами, у нас есть много рахныъ объектов, и мы хотим, чтобы каждый из них делал что-то свое. При этом можно разделить типы между соответствующими массивами. 
- Хранит объекты тесно упакованными, нет байтов добивки или других странностей
- Статическая диспетчеризация. С момента, как мы знаем конкретные типы, нам не нужен полиморфизмы, мы можем изпользовать обычные, невиртуальные методы. 
- Вам нужно отслеживать кучу коллекций. Если у вас много разных типов объектов, накладные расходы и сложность поддержки отдельных массивов для каждого из них могут стать рутиной.
- Вам нужно знать о каждом типе. Поскольку вам нужно поддерживать отдельные коллекции для каждого типа, вы не можете быть отделены от набора классов. Часть магии полиморфизма заключается в том, что он открыт — код, работающий с интерфейсом, может быть полностью отделен от потенциально большого набора типов, реализующих этот интерфейс.

**Использовать коллекцию ссылок:**
Если не нужно беспокоиться о кэше, это хорошее решение. Храним массив ссылок на базовый класс или тип интерфейса, получаем нужный пполиморфизм, и объекты могут иметь любой размер
- Это гибко. Работает с любыми объектами, поддерживающими интерфейс.
- Менее дружелюбно к кэшу. Больше кэш-промахов, так как ссылки могут указывать на любое место в памяти.

## Размотка циклов
Если заранее известно количество итераций, то можно полностью размотать цикл, либо следующим образом:
```cs
ShapeCount /= 4;
while(ShapeCount--)
{
	Accum0 += GetAreaSwitch(Shapes[0]);
	Accum1 += GetAreaSwitch(Shapes[1]);
	Accum2 += GetAreaSwitch(Shapes[2]);
	Accum3 += GetAreaSwitch(Shapes[3]);
	
	Shapes += 4;
}
```

## Другое
- Запускать циклы в Update только по условию
- Задавать коллекциям оценочную емкость
- Приведение float к int дешевле чем к строке с форматом "0."
- Если часто нужно приводить float к string, например на каждом кадре обновлять какое-то значение, которое не меняется, то можно создать словарь число-строка
- По возможности откладывать взятие длины вектора и его нормализацию
- Избегать использования `Mathf.Sqrt` и `Vector3.magnitude`
- Условия для проверки:
```cs
if (cheapToCheck() && reallyExpensiveCheck()) DoThing();
```
- Изменение порядка умножения: не float * Vector * float, а сначала чисоа и только потом векторы
- Если нет необходимости выполнять операцию за один кадр, то разбить на несколько. Например, поиск пути для врагов можно выполнить за несколько кадров, а не в одном. Как альтернативу, дорогостоящую операцию можно вызывать раз в несколько кадров. 
- Использовать `obj.GetInstanceId()` для ключей в словаре. При необходимости его можно сохранить как публичное поле в скрипте в Awake (кэшировать)
- При необходимости можно использовать `List` для обхода объектов, и `HashSet`  в случае если нужно быстро получить доступ к элементу. Если часто будет удаление, то сделать Linked List или Intrusively linked list

## Лямбды
Если лямбда не захватывает какой-то контекст (замыкание), то оно кэшируется, иначе, каждый раз будет создаваться новый класс для контекста, выделяя память в хипе.

Преобразуем этот код:
```cs
string GetOrCreate(string key, Func<string> evaluator)
{
	string ret = evaluator();
}

string Substring(string x)
{
	var ret = GetOrCreate(x, () => x.Substring(1));
}
```

В этот:
```cs
string GetOrCreate(string key, Func<string, string> evaluator)
{
	string ret = evaluator(key);
}

string Substring(string x)
{
	var ret = GetOrCreate(x, (newX) => newX.Substring(1));
}
```

Разница в том, что в первом случае мы передаем x в качестве тела лябмды, а во втором передаем в качестве аргумента в методе `GetOrCreate`, таким образом эта лямбда будет кэширована. 

Можно передавать контекст
```cs
string GetOrCreate<T>(string key, T context, Func<string, T, string> evaluator)
{
	string ret = evaluator(key, context);
}

string Substring(string x)
{
	var ret = GetOrCreate(x, y, (newX, newY) => newX + newY);
}
```

Или так:

```cs
interface IPredicate<T>
{
	bool Invoke(T obj);
}
```

```cs
using System.Collections.Generic;
 
public static partial class ListExtensions
{
	public static int Find<T>(this List<T> list, IPredicate<T> pred)
	{
		for (int i = 0, count = list.Count; i < count; ++i)
		{
			if (pred(list[i])
			{
				return i;
			}
		}
		return -1;
	}
}
```

```cs
class ContainsPredicate : IPredicate<int>
{
	public int Val;
 
	public bool Invoke(int obj)
	{
		return obj == Val;
	}
}
 
bool Contains(int val, List<int> list)
{
	ContainsPredicate pred = new ContainsPredicate { Val = val };
	return list.Find(pred) >= 0;
}
```

## LINQ
Не использовать в местах где он будет часто вызываться, генерирует как аллокации для лямбд, так и итераторы

## Foreach
Если использовать foreach  в коллекциях через получение IEnumerator то это вызовет боксинг. При этом итерирование по списку и по массиву нет



## Transform
When moving Transforms, use `Transform.SetPositionAndRotation` to update
both position and rotation at once. This avoids the overhead of modifying a
transform twice.

If you need to Instantiate a `GameObject` at runtime, a simple optimization is to
parent and reposition during instantiation:
```cs
GameObject.Instantiate(prefab, parent);
GameObject.Instantiate(prefab, parent, position, rotation);
```

## Audio
- Start with your sound assets in a lossless file format like WAV or AIFF.
- Enable the Force To Mono option on stereo audio files if they do not require stereo sound; this saves runtime memory and disk space.
- Preload Audio Data ensures that Unity will load any referenced AudioClips before initializing the Scene. However, this may increase Scene loading times.
- If your sound clip is not needed immediately, load it asynchronously. Check Load in Background. This loads the sound at a delayed time on a separate thread, without blocking the main thread.
- Set the Sample Rate Setting to Optimize Sample Rate or Override Sample Rate. For mobile platforms, 22050 Hz should be sufficient. Use 44100Hz (i.e., CD quality) sparingly. 48000Hz is excessive. For PC/console platforms, 44100Hz is ideal. 48000Hz is usually unnecessary.
- Compress the AudioClip and reduce the compression bitrate.
	- For mobile platforms, use Vorbis for most sounds (or MP3 for sounds not intended to loop) . Use ADPCM for short, frequently used sounds (e.g., footsteps, gunshots).
	- For PC/Xbox, use Microsoft’s XMA format instead of Vorbis or MP3. Microsoft recommends a compression ratio between 8:1 and 15:1.
	- For Playstation, use the ATRAC9 format. This has less CPU overhead than Vorbis or MP3.
- ![[Screenshot_20241022_225158.png]]
- The SFX Reverb Effect is one of the most expensive audio effects in the AudioMixer. Adding a mixer group with SFX Reverb (and a mixer group sending to it) increases CPU cost.
- Reduce the number of mixer groups to improve AudioMixer performance. Adding a large number of child groups under a single parent group increases audio CPU cost significantly. This happens even if all AudioSource outputs straight to Master, since Unity’s DSP does not distinguish null signals
- Avoid parents with a single child group. Whenever possible, combine the two mixer groups into one.


## Animation для простых анимаций
При возможности стоит использовать твины, или Legacy Animation system

## Разделение канвасов
Канвас использует меши для представления элементов и регенирирует их при изменении. Генерация этих мешей может быть затратной. Они должны быть помещены в batch чтобы было как можно меньше draw calls. Проблема в том, что когда один элемент канваса меняется, весь канвас должен быть проанализирован заново чтобы понять как отрисовывать его элементы. 

Так же можно использовать nesting. Дочерние канвасы изолируют содержимое и от родителей, и от "братьев". Они сами управляют своей геометрией и батчами. Один из способов разделения - разделение по частоте использования. Выносить статические элементы на отдельный канвас, а элементы, которые будут обновлены в одно время на другой канвас. Так же убедитесь, что все элементы в одном канвасе содержат одни и те же значения Z, материалы и текстуры. 

## Raycast
По сути graphic raycaster не кастует лучи, а смотрит, какие элементы пересекаются с input.
> Remove Graphic Raycasters from non-interactive UI Canvases and turn off the **Raycast Target** for static or non-interactive elements.

Например, тексту на кнопке не нужен raycast, и так далее.
Использование канваса в режиме Worldspace или Screenspace в зависимости от blocking mask заставит raycast работать как физический raycast в режиме 2d или 3d. Использовать это как можно реже.

## Дорогостогоящие элементы.
Grid'ы, списки с большим количеством элементов, накладываюшиеся элементы дорого обходятся. Например стоит использовать object pool для элементов scroll list, так как мы видим не все элементы за раз, то можно переиспользовать те, которые мы вне зоны видимости

## Избегать layout group
Every UI Element that marks its layout as “dirty” will perform, at minimum, one GetComponent call. This call looks for a valid layout group on the layout element’s parent. If it finds one, it continues walking up the Transform hierarchy until it stops seeking layout groups or reaches the hierarchy root; whichever comes first. As such, each layout group adds one GetComponent call to each child layout element’s dirtying process, making the nested layout groups extremely bad for performance.

При большом количестве таких элементов, используйте anchor и свои скрипты для расчета их layout. Но выполняйте их только когда все изменения будут внесены, а не после каждого. 

## Правильный pooling объектов
Сначала отключите объект, а затем уже перенесите его в пул (reparent). Когда достаете из пула, сначала reparent, потом обновите данные, потом включите его. 

## Отключение компонента канваса
Отключение компонента канваса перестанет вызывать draw calls на gpu,  но при этом он не уничтожит своей vertex buffer и сохранит свои меши и вертексы. Когда вы его включите, он не потребует rebuild, просто начнет их отрисовывать. Так же отключение компонента не вызовет дорогостоящие методы OnDisable / OnEnable вниз по иерархии. Нужно только не забыть отключить дорогостоящие дочерние скрипты. 

## Использование аниматоров и UI
Аниматоры будут помечать элементы как dirty, даже если ничего не изменилось. Использовать это только для элементов которые постоянно меняются. Для тех что меняются редко используйте код. 

## Полный экран
Если экран паузы занимает все место (сцена не видна), то отключайте камеру, канвасы позади, так же можно снизить targetFrameRate.

## Отключение Pixel Perfect 
На канвасе с динамическими элементами стоит отключать pixel perfect 

## Отключение скроллинга при маленькой скорости
Использование стандартного Scroll Rect может привести к тому, что даже при видимой остановке скроллинга, элементы будут двигаться чуть-чуть по инерции, таким образом вызывая перерисовку канваса. 

## Устанавливать свойство camera в канвасах
