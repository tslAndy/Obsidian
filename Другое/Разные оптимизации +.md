## Убирать лишнюю работу

Код ниже пройдется по всем элементам коллекции, хотя по факту можно прекратить после 12 элементов, в этом случае придумать метод который будет обрываться после 12.  
```cs
collection.Count(predicate) > 12;
```

## Структуры вместо строк как ключи
Сравнение строк требует много ресурсов, эффективнее будет создать структуру, реализующую интерфейс `IEquatable<T>`:

```cs
public struct Key : IEquatable<Key>
{
    public string Type;
    public string Name;
 
    public Key(string type, string name)
    {
        this.Type = type;
        this.Name = name;
    }
 
    public override bool Equals(object obj)
    {
        if (obj is Key)
        {
            return this.Equals((Key)obj);
        }
        return false;
    }
 
    public bool Equals(Key other)
    {
        return this.Type.Equals(other.Type) && this.Name.Equals(other.Name);
    }
 
    public override int GetHashCode()
    {
        var h1 = this.Type.GetHashCode();
        var h2 = this.Name.GetHashCode();
        return (((h1 << 5) + h1) ^ h2);
    }
}
```

## Сравнение строк
При использовании `String.Equals()` and `String.Compare()` без аргумента `StringComparison` используется значение по умолчанию `StringComparison.CurrentCulture`. Во-первых, это может привести к неожиданному поведению, во-вторых это не слишком эффективно. При возможности стоит передавать `StringComparison.Ordinal` или `StringComparison.OrdinalIgnoreCase`, особенно в случае если используется константа:

```cs
string.Equals(“https”, uri.Schema)

string.Equals(“https”, uri.Schema, StringComparison.OrdinalIgnoreCase)
```

Второй метд поддерживает быстрое сравнение по 40 байт, сравнивая 4 байта int-сравнение если поддерживается `SIMD`.

## `String Split`
Аллоцирует массив `int` с индексами разделителей и массив строк для подстрок. Это тратит ресурсы сборщика мусора. Когда нужна одна подстрока из изначальной, лучше найти индекс по которому нужно разделить и потом вызвать `String.Split` по этому индексу. То же можно применить если известно ожидаемое количество строк, найти индексы разделителей и резать по ним. 

Метод `Split` принимает массив разделителей. Отдавать предпочтение `char[]`. Желательно не аллоцировать новый массив для разделителей при каждом вызове, т. е. когда мы вызываем `text.Split('X')` по факту мы вызываем `text.Split(new char[]{'​​​​X'}​​​​​​)`. Если мы знаем, сколько ожидаем строк, предоставить это в аргумент `count`, это позволит избежать недостаточного или избыточного аллоцирования. 

## `String.Replace`
При использовании одного символа использовать `char` а не `string`:
```cs
input = input.Replace("_", "-");

input = input.Replace('_', '-');
```

Если хочется пострадать хуйней, можно написать свой метод, который создаст свой `StringBuilder`, просканирует исходную строку сивол за символом, если надо добавит символ или его замену.

## LINQ evaluation
```cs
private static void RangeIEnumerable()
{
    var enumeration = Enumerable.Range(0, 1000);
    for (int i= 0; i < 10;  i++)
    {
        long count = enumerable.Max();
    }
}
 
private static void RangeList()
{
    var list = Enumerable.Range(0, 1000).ToList();
    for (int i = 0; i < 10; i++)
    {
        var count = list.Max();
    }
}
```

`LINQ` использует `IEnumerable`, поэтому при каждом вызове enumerable.Max() создается новая коллекция, поэтому метод со списком намного быстрее. 


Другая проблема в том, что реализации методов `LINQ` часто не оптимизированны для структур данных, что может вылиться в кважратичную сложность. 

Предположим, что у нас есть список важных векторов и список предоставленных векторов от пользователя, и хотим их отфильтровать. (10 итераций для упрощения измерений). 
```cs
HashSet<Vector3> importantVectorsHashSet = Enumerable.Range(0, 100).Select(x => x * Vector3.one).ToHashSet();
 
private static void ContainsIEnumerable(IEnumerable<Vector3> userProvidedVectors, IEnumerable<Vector3> importantVectors)
{
    for (int i = 0; i < 10; i++)
    {
        var important = userProvidedVectors.Where(v => importantVectors.Contains(v)).ToList();
    }
}
 
ContainsIEnumerable(userProvided, importantVectorsHashSet);
```

`importantVectors.Contains(v)` являтеся вызовом со сложностью O(N), так как перебирает все значения, несмотря на то, что в `HashSet` есть метод Contains сложностью O(1).

Данный код с линейной сложностью:
```cs
private static void ContainsHashSet(IEnumerable<Vector3> userProvidedVectors, HashSet<Vector3> importantVectors)
{
    for (int i = 0; i < 10; i++)
    {
        var important = userProvidedVectors.Where(v => importantVectors.Contains(v)).ToList();
    }
}
```

## List.Clear() вместо new List()
Очистка коллекции не обязательно освобождает занятую ей память, но при этом дешевле, чем создание новой

## Кэширование значений
Transform и множетсво других свойств можно кэшировать

## Вызов функции по таймеру
Если дорогостоящая функция не обязательно должна вызываться на каждом кадре, то ее можно запускать по таймеру

## Полиморфизм
Избегать субклассирования в местах, которые оптимизируются для кэша. 
- Это безопасно и просто. Вы точно знаете, с каким классом работаета, и, очевидно, все объекты одного размера. 
- Это быстро. Динамеческая диспетчеризация означает поиск метода в виртуальной таблице методов, стоимость отличается в зависимости от оборудования, но она есть в любом случае
- Это негибко. Если мы хотим, чтобы некоторые объекты имели свой стиль рендеринга или свои атаки и движения, виртуальные методы это хороший способ реализовать это. Использование одного метода с `switch` плохая идея.

**Используйте отдельный массив для каждого типа**:
Мы используем полиморфизм чтобы вызывать поведение у объектов, чей тип мы не знаем. Другими словами, у нас есть много рахныъ объектов, и мы хотим, чтобы каждый из них делал что-то свое. При этом можно разделить типы между соответствующими массивами. 
- Хранит объекты тесно упакованными, нет байтов добивки или других странностей
- Статическая диспетчеризация. С момента, как мы знаем конкретные типы, нам не нужен полиморфизмы, мы можем изпользовать обычные, невиртуальные методы. 
- Вам нужно отслеживать кучу коллекций. Если у вас много разных типов объектов, накладные расходы и сложность поддержки отдельных массивов для каждого из них могут стать рутиной.
- Вам нужно знать о каждом типе. Поскольку вам нужно поддерживать отдельные коллекции для каждого типа, вы не можете быть отделены от набора классов. Часть магии полиморфизма заключается в том, что он открыт — код, работающий с интерфейсом, может быть полностью отделен от потенциально большого набора типов, реализующих этот интерфейс.

**Использовать коллекцию ссылок:**
Если не нужно беспокоиться о кэше, это хорошее решение. Храним массив ссылок на базовый класс или тип интерфейса, получаем нужный пполиморфизм, и объекты могут иметь любой размер
- Это гибко. Работает с любыми объектами, поддерживающими интерфейс.
- Менее дружелюбно к кэшу. Больше кэш-промахов, так как ссылки могут указывать на любое место в памяти.

## Размотка циклов
Если заранее известно количество итераций, то можно полностью размотать цикл, либо следующим образом:
```cs
ShapeCount /= 4;
while(ShapeCount--)
{
	Accum0 += GetAreaSwitch(Shapes[0]);
	Accum1 += GetAreaSwitch(Shapes[1]);
	Accum2 += GetAreaSwitch(Shapes[2]);
	Accum3 += GetAreaSwitch(Shapes[3]);
	
	Shapes += 4;
}
```

## Другое
- Запускать циклы в Update только по условию
- Задавать коллекциям оценочную емкость
- Приведение float к int дешевле чем к строке с форматом "0."
- Если часто нужно приводить float к string, например на каждом кадре обновлять какое-то значение, которое не меняется, то можно создать словарь число-строка
- По возможности откладывать взятие длины вектора и его нормализацию
- Избегать использования `Mathf.Sqrt` и `Vector3.magnitude`
- Условия для проверки:
```cs
if (cheapToCheck() && reallyExpensiveCheck()) DoThing();
```
- Изменение порядка умножения: не float * Vector * float, а сначала чисоа и только потом векторы

