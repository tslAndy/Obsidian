#refactor
## Change Value to Reference
**Есть много одинаковых экземпляров одного класса, которые можно заменить одним объектом.**
Превратите одинаковые объекты в один объект-ссылку.

![[Pasted image 20240818181609.png]]

## Change Reference to Value
**У вас есть объект-ссылка, который слишком маленький и неизменяемый, чтобы оправдать сложности по управлению его жизненным циклом.** Превратите его в объект-значение.

![[Pasted image 20240818181715.png]]

## Duplicate Observed Data
**Данные предметной области программы хранятся в классах, отвечающих за пользовательский интерфейс (GUI).**
Имеет смысл выделить данные предметной области в отдельные классы и, таким образом, обеспечить связь и синхронизацию между классом предметной области и GUI.

![[Pasted image 20240818181824.png]]

## Self Encapsulate Field
**Вы используете прямой доступ к приватным полями внутри класса.**
Создайте геттер и сеттер для поля, и пользуйтесь для доступа к полю только ими.
```cs
class Range 
{
  private int low, high;
  
  bool Includes(int arg) 
  {
    return arg >= low && arg <= high;
  }
}

//------------------------------------------------------------------------

class Range 
{
  private int low, high;
  
  int Low {
    get { return low; }
  }
  int High {
    get { return high; }
  }
  
  bool Includes(int arg) 
  {
    return arg >= Low && arg <= High;
  }
}
```

## Replace Data Value with Object
**В классе (или группе классов) есть поле простого типа. У этого поля есть своё поведение и связанные данные.**
Создайте новый класс, поместите в него старое поле и его поведения, храните объект этого класса в исходном классе.
![[Pasted image 20240818182039.png]]

## Replace Array with Object
**У вас есть массив, в котором хранятся разнотипные данные.**
Замените массив объектом, который будет иметь отдельные поля для каждого элемента.

```cs
string[] row = new string[2];
row[0] = "Liverpool";
row[1] = "15";

//------------------------------------------------------------------------

Performance row = new Performance();
row.SetName("Liverpool");
row.SetWins("15");
```

## Change Unidirectional Association to Bidirectional
**У вас есть два класса, которым нужно использовать фичи друг друга, но между ними существует только односторонняя связь.**
Добавьте недостающую связь в класс, в котором она отсутствует.

![[Pasted image 20240818183139.png]]

## Change Bidirectional Association to Unidirectional
**У вас есть двухсторонняя связь между классами, но один из классов больше не использует фичи другого.**
Уберите неиспользуемую связь.

![[Pasted image 20240818183231.png]]

## Encapsulate Field
**У вас есть публичное поле.**
Сделайте поле приватным и создайте для него методы доступа.
```cs
class Person 
{
  public string name;
}

//------------------------------------------------------------------------

class Person 
{
  private string name;

  public string Name
  {
    get { return name; }
    set { name = value; }
  }
}
```

## Encapsulate Collection
**Класс содержит поле-коллекцию и простой геттер и сеттер для работы с этой коллекцией.**
Сделайте возвращаемое геттером значение доступным только для чтения и создайте методы добавления/удаления элементов этой коллекции.

![[Pasted image 20240818183428.png]]

## Replace Magic Number with Symbolic Constant
**В коде используется число, которое несёт какой-то определённый смысл.**
Замените это число константой с человеко-читаемым названием, объясняющим смысл этого числа.
```cs
double PotentialEnergy(double mass, double height) 
{
  return mass * height * 9.81;
}

//------------------------------------------------------------------------

const double GRAVITATIONAL_CONSTANT = 9.81;

double PotentialEnergy(double mass, double height) 
{
  return mass * height * GRAVITATIONAL_CONSTANT;
}
```

## Replace Type Code with Class
> Кодирование типа - вместо отдельного типа данных вы имеете набор чисел или строк, который составляет список допустимых значений для какой-то сущности. Зачастую этим конкретным числам и строкам даются понятные имена с помощью констант, что и является причиной их широкого распространения.

**В классе есть поле, содержащее кодирование типа. Значения этого типа не используются в условных операторах и не влияют на поведение программы.**
Создайте новый класс и применяйте его объекты вместо значений закодированного типа.

![[Pasted image 20240818183729.png]]

## Replace Type Code with Subclasses
**У вас есть закодированный тип, который непосредственно влияет на поведение программы (основываясь на значениях этого поля, в условных операторах выполняется различный код).**
Для каждого значения закодированного типа, создайте подклассы. А затем, вынесите соответствующие поведения из исходного класса в эти подклассы. Управляющий код замените полиморфизмом.

![[Pasted image 20240818183842.png]]

## Replace Type Code with State/Strategy
**У вас есть закодированный тип, который влияет на поведение, но вы не можете использовать подклассы, чтобы избавиться от него.**
Замените кодирование типа объектом-состоянием. При необходимости заменить значение поля с кодированием типа, в него подставляется другой объект-состояние.

![[Pasted image 20240818183930.png]]

## Replace Subclass with Fields
**У вас есть подклассы, которые отличаются только методами, возвращающими данные-константы.**
Замените методы полями в родительском классе и удалите подклассы.

![[Pasted image 20240818184014.png]]
