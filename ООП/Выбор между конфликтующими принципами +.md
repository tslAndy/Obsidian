#oop
## Четыре проблемы, которые решают принципы программирования
### Поддерживаемость
Поддерживаемость — это первая причина, о которой кто-то думает, когда решает использовать принцип. Это основная причина для соблюдения принципов программирования, поскольку это существенно влияет на нашу производительность. Речь идет не только о модификации частей нашего кода, но и о добавлении новых функций, удалении устаревших разделов, рефакторинге для удобства внесения изменений в будущем и обеспечении читабельности. Код, который трудно понять, изначально трудно поддерживать.
### Тестируемость
Тестируемость — еще один важный аспект, который решается архитектурными решениями, основанными на принципах программирования. Это включает в себя традиционные тесты (модульные, интеграционные, сквозные и т. д.), но выходит за рамки этого. Даже если кто-то не использует формальные тесты, ему все равно нужно тестировать поведение своей программы.

Например, даже если мы не используем автоматические тесты в игре, которую мы делаем в Unity, мы должны иметь возможность тестировать изолированно определенные ее части. Если мы хотим протестировать контроллер персонажа, но нам нужно добавить к сцене весь уровень в дополнение к нашему персонажу, потому что наш сценарий персонажа зависит от него, но наш уровень зависит от нашего игрового менеджера синглтона, который также может иметь некоторые зависимости, мы ограничиваем нашу производительность огромным количеством времени, которое нам нужно потратить на настройку сцены, просто для проверки нашего сценария контроллера.

### Отладка
Отладка — это задача, с которой сталкивается каждая программа и программист. Ее можно разделить на две части: поиск ошибки в коде и ее исправление.

Легкость поиска ошибки зависит от архитектуры нашего кода и типа ошибки. Многопоточные ошибки и проблемы с параллельным выполнением, как известно, трудно обнаружить, но часто их легко исправить. И наоборот, алгоритмические ошибки обычно легче найти, но сложнее устранить.

Нам нужно учитывать тип программирования, который мы делаем, и следовать принципам, которые создают архитектуру, которая облегчит отладку нашего кода. Это означает структурирование нашего кода таким образом, чтобы ошибки можно было быстро обнаружить в небольших изолированных частях кодовой базы или гарантировать, что исправление ошибки не потребует значительных изменений в других частях кода.

### Параллельное программирование
Последняя проблема, которую должна решить наша архитектура, часто упускается из виду новыми программистами: параллельное программирование. Наша архитектура кода должна быть разработана с принципами, которые позволяют нескольким программистам работать над одной и той же кодовой базой одновременно, не мешая друг другу.

Это означает, что наша архитектура должна позволять каждому программисту работать независимо над определенными частями кода. Например, один программист должен иметь возможность работать над классом, не влияя на его прогресс со стороны других, и эта часть должна легко интегрироваться в остальную часть программы. Если наша кодовая база содержит глобальные переменные или, что еще хуже, глобальное состояние, не имеет определенных контрактов или четкого API, программисты будут испытывать снижение производительности. Им придется ждать изменений, находящихся вне их ответственности, что создаст узкие места в процессе разработки.

## Примеры ситуаций с противоречивыми принципами программирования

Перед применением принципа программирования, который повлияет на нашу архитектуру, наиболее важный вопрос, который следует задать, это: **`What problem am I trying to solve ?`**

Худшее, что может сделать программист, — это слепо применять принципы, как будто это правила, или, что еще хуже, отдавать предпочтение одному принципу перед другими во всех ситуациях. Например, говоря в общем: «Мне не нравится принцип X; я предпочитаю принцип Y, потому что он лучше по причине Z». При изучении принципа важно понимать, почему он был создан и какую проблему он призван решить.
### [[Open - Closed Principle +]] против [[YAGNI]]
OCP позволяет легко расширять наш код с помощью интерфейсов, что обычно делается через [[Стратегия +]]. YAGNI, с другой стороны, говорит нам не пытаться добавлять в нашу кодовую базу то, что не нужно на момент написания.

Какой из них мы будем использовать, зависит от ситуации. Каковы требования? Ожидаем ли мы, что они изменятся? Как долго нам придется поддерживать эту кодовую базу? Также, подвержен ли конкретный фрагмент кода ошибкам? Часто ли нам приходится его тестировать? Отлаживать? Ожидаем ли мы, что другие люди будут использовать этот код?

### [[Interface Segregation Principle +]] против слишком многих абстракций
Абстракции позволяют нам определить, что может делать объект, а не то, чем он является. С другой стороны, одна из моих любимых цитат, приписываемых Дэвиду Уилеру, звучит так: **`We can solve any problem by introducing an extra level of indirection, except for the problem of too many levels of indirection`**

Добавление абстракций может снизить алгоритмическую когнитивную сложность определенных частей нашего кода. Однако это преимущество может быть перевешено, если когнитивная сложность увеличится из-за многочисленных зависимостей между слишком большим количеством абстракций.

Опять же, то, что мы выберем, зависит от проблемы, которую мы пытаемся решить. Возникают ли у нас трудности с тестированием или отладкой определенного фрагмента кода? Или у нас возникают трудности с его пониманием из-за всех зависимостей. Являемся ли мы единственным программистом, использующим его, или ожидаем, что другие программисты тоже будут от него зависеть?

### Избегание [[Temporal Coupling +]] против [[POLA]]
Temporal Coupling — это принцип, который говорит нам инкапсулировать поведения, которые должны выполняться в определенном порядке. С другой стороны, принцип наименьшего удивления говорит нам, что система должна вести себя так, как ожидается, без каких-либо сюрпризов.

Бывают моменты, когда нам приходится выбирать между двумя вариантами: иметь вызов метода, который выполняет непредвиденное действие для предотвращения ошибок (например, открытие файла перед чтением из него), или иметь метод, который ведет себя ожидаемым образом, но требует от программиста сначала вызвать другой метод, чтобы гарантировать его правильное выполнение.

Решение снова сводится к проблеме, которую мы пытаемся решить, кто будет использовать этот код? Есть ли у нас автоматизированные тесты? Должно ли первое поведение произойти только перед одним методом или есть много методов, которые его требуют? Если ошибка действительно произойдет из-за временной связи, насколько легко будет ее найти и исправить?

### [[Single Responsibility Principle +]] против [[Принцип Tell Don't Ask +]]
Одно из применений принципа tell don't ask — избегать вопросов о состоянии другого объекта. Очевидно, что это может быть нарушением SRP, поскольку у другого объекта могут быть другие причины для изменения, и, следовательно, наш объект тоже может измениться. Опять же, решение зависит от программистов и их приоритетов.

Кто будет использовать этот тип? Ожидаем ли мы, что он изменится? Реализует ли он основную бизнес-логику или находится на краю нашей архитектуры? Что произойдет, если в нем есть ошибка, повлияет ли эта ошибка на многие другие части нашей кодовой базы? Если мы решим, что не будем внутренне проверять состояние другого объекта, вводит ли это временную связь?

### [[Закон Деметры +]]
Представляет собой скорее принцип, чем закон (еще одно более подходящее название для него — принцип наименьшего знания), в определенных ситуациях может противоречить многим принципам.

Например, создание метода, который инкапсулирует эти знания, может противоречить YAGNI, поскольку этот метод будет использоваться только одним классом. Он также может отвечать за создание интерфейсов с большим количеством методов, что противоречит ISP, или даже может повлиять на производительность нашей программы из-за слишком большого количества методов-оберток.

Архитектурные решения могут повлиять на другие аспекты нашей программы, включая ее производительность. Хотя принципы программирования призваны повышать производительность путем решения проблем, упомянутых ранее, мы должны помнить, что у конечной программы могут быть особые требования к производительности. Мы не должны усложнять наш код исключительно ради производительности, особенно если эта производительность не требуется нашими спецификациями. И наоборот, в приложениях, критичных к производительности, удовлетворение потребностей конечного пользователя в производительности имеет приоритет над другими соображениями.