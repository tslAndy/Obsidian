#oop
## Что такое примитивная одержимость
Важным аспектом объектно-ориентированного программирования является возможность создания пользовательских типов. Для пользователей тип определяется его поведением, а не данными. Например, 32-битное целое число и 32-битное число с плавающей точкой содержат одни и те же данные, 32 бита, которые могут быть нулём или единицей, но между целым числом и числом с плавающей точкой есть чёткое различие из-за их различного поведения (или операций в контексте числовых типов).

Примитивная одержимость — это использование примитивных типов (например, int, float, string) для представления концепций более высокого уровня. Хотя это не всегда плохо, чрезмерная зависимость от примитивных типов может негативно повлиять на читаемость программы, простоту обслуживания, отладки и корректность.

## Примитивы как типы
Во многих случаях программист может использовать примитивный тип вместо типа более высокого уровня. Например:
```cs
int age = 20;
float damage = 10f;
```
Здесь мы используем int для представления возраста и float для представления урона. Если возраст и урон являются важными концепциями в нашей программе, то использование примитивных типов для их представления в разных местах нашего кода может создать определенные проблемы:

### Потеря безопасности типов и проверка границ
Одна из проблем, которую создает примитивная одержимость, заключается в том, что мы теряем безопасность типов более высокого уровня. В предыдущем примере значения, которые может иметь переменная age, являются подмножеством значений, которые может содержать целочисленный тип. Например, переменная age никогда не может быть отрицательной, или, если она представляет возраст взрослого человека, она никогда не может быть меньше 18.

То же самое относится и к нашей переменной урона. Хотя она никогда не должна быть отрицательной, можно легко допустить ошибку, в результате которой ей будет присвоено недопустимое значение. Хуже того, кто-то может легко написать что-то вроде этого:

```cs
damage = age;
```

Очевидно, это не имеет смысла, но поскольку у нас нет безопасности типов, компилятор не будет жаловаться.

### Поведение примитивов, не применимое к нашему представленному типу
Другая проблема, которая возникает при использовании примитивных типов для представления концепций домена, заключается в том, что эти типы могут включать поведение, которое не имеет смысла для наших концепций. Например, с нашими предыдущими переменными деление возраста на другой возраст или вычитание повреждения из повреждения будет разрешено компилятором без ошибок, поскольку компилятор понимает только целые числа, а не конкретные концепции повреждения и возраста.

Если бы мы создали свои собственные типы, мы могли бы определить соответствующее поведение и перегрузить операторы, которые имеют смысл для этих типов. Любые другие операции, разрешенные для типов int и float, привели бы к ошибкам компилятора. Кроме того, мы могли бы перегрузить проверенные операторы логикой, специфичной для наших типов, гарантируя, что любые переполнения или недополнения будут обнаружены компилятором.

### Проблема подразумеваемого «если»
Проблема, которую создает примитивная одержимость и которая действительно может сделать наш код более сложным, трудным для поддержки и трудным для рассуждения, — это то, что называется проблемой подразумеваемых if. Короче говоря, когда мы используем примитивы для представления концепции, мы можем непреднамеренно создавать переменные, которые представляют две разные вещи, в зависимости от их текущего значения. Примером этого является целочисленная переменная урона, которая представляет урон, когда она имеет положительное значение, и исцеление, когда она имеет отрицательное значение. Это создает проблемы в нашей кодовой базе, потому что оператор if подразумевается. В конце концов, подразумеваемый оператор if приводит к большему количеству подразумеваемых операторов if, пока программист не потратит больше умственных усилий на запоминание всех этих подразумеваемых правил, чем на обдумывание новых решений для своего кода.

Подробнее тут: [[Подразумеваемый if +]]

### Решение: Кастомный неизменяемый объекта-значения вместо примитивов
Решение проблемы «запаха кода» из-за одержимости примитивами, когда она проявляется в использовании примитивов вместо доменных типов, заключается в создании кастомных неизменяемых объектов значений, которые оборачивали бы примитивы и выполняли необходимые проверки.

Эти типы могут иметь правила проверки, чтобы гарантировать, что они всегда представляют допустимое состояние, а также могут содержать любое общее поведение. Эти объекты значений должны быть неизменяемыми и иметь равенство значений.

В C# есть два механизма, которые могут нам в этом помочь. Оба избавляют нас от написания большого количества шаблонного кода. Это `record` и `record struct`. Оба имеют переопределенное поведение для проверки равенства объектов, `record struct` это тип значений, и они больше подходят для обертки примитивов-значений для избежания боксинга, и модификатор `readonly` обеспечит неизменяемость структуры. Для record-класса нужно обеспечить иммутабельность самим. 

## Несколько операторов if вместо стратегии (нарушение OCP)
Другим проявлением запаха кода примитивной одержимости является использование примитивного значения исключительно в качестве идентификатора для нескольких различных случаев. Это часто приводит к блоку кода с многочисленными операторами if или большим оператором switch, каждый из которых содержит значительное количество логики. 

## Примитивы как параметры
Наконец, примитивная одержимость может также проявляться, когда мы передаем примитивы в качестве параметров методам. Хотя иногда примитивный параметр уместен, часто у нас есть код, который извлекает значение из объекта, а затем передает это значение в качестве параметра.

Например, предположим, что у нас есть тип `Driver` со свойством `age` типа `int`. Тип `Driver` выполняет все необходимые проверки всякий раз, когда мы устанавливаем свойство `age`, гарантируя, что каждый объект `Driver` всегда находится в допустимом состоянии. Теперь предположим, что нам нужно создать метод в другом классе, который принимает возраст водителя и после некоторых вычислений возвращает процент аварий, которые случаются с водителями этого возраста. У нас может возникнуть соблазн создать этот метод с `int` параметром `age`, но это будет примитивным запахом кода одержимости.

Причина в том, что хотя возраст водителя имеет тип `int`, тип `Driver` выполняет все необходимые проверки, чтобы убедиться, что значение возраста находится в соответствующих пределах. Однако метод может принимать любое `int`значение. Правильный подход заключается в том, чтобы наш метод принимал объект `Driver`, а затем извлекал значение возраста из свойства age объекта `Driver` в методе.

### Заблуждение о меньшем количестве зависимостей
Некоторые могут подумать, что использование типа `Driver` в качестве параметра вместо `int` неправильно, поскольку это создает больше зависимостей в нашем коде. В конце концов, чем меньше зависимостей у каждого типа, тем проще понять код.

Хотя верно, что мы должны стремиться минимизировать зависимости между классами, это скорее концептуальная проблема, чем техническая. Использование типа `int` устраняет только техническую зависимость, но концептуально зависимость от типа `Driver` все еще существует. Параметр в нашем методе не является истинно типом, `int` поскольку он не может принимать все значения, которые `int` может принимать тип. Вместо этого он ограничен теми же правилами, что и свойство age в типе `Driver`.

У нас есть подразумеваемая зависимость между этим методом и типом `Driver`, где параметр метода и свойство возраста `Driver`'s всегда должны подчиняться тем же правилам и ограничениям. Любое изменение проверок `Driver`'s должно быть отражено в проверках метода. Подразумеваемые зависимости, такие как подразумеваемые операторы `if`, создают проблемы со сложностью нашего кода.

### Решение: Передача объектов в качестве параметров
Меньше зависимостей полезно, но подразумеваемый код, вероятно, худшее, что есть в кодовой базе. Все подразумеваемое должно быть явно записано, чтобы любой читатель мог это понять. По этой причине наш метод должен иметь параметр `Driver`, поскольку он явно указывает на существующие зависимости.

Одним из решений проблемы запаха кода примитивных параметров является постоянная передача объекта, содержащего примитивный тип, в допустимом состоянии, вместо его извлечения, передачи в качестве параметра и последующего выполнения тех же проверок для подтверждения его состояния, что и в типе объекта.

### Решение: Создать объект параметров
Иногда мы можем передавать примитивы в метод, который не принадлежит типу. Например, давайте рассмотрим метод, который создает врага случайного уровня, принимая два параметра: минимальный и максимальный уровень врага в виде целых чисел.

Это может быть подвержено ошибкам, так как мы можем непреднамеренно передать минимальный уровень, который выше максимального уровня. Конечно, мы можем включить соответствующие проверки в наш метод. Однако, если мы обнаружим, что используем эти два значения в более чем паре методов, более уместно ввести новый тип, такой как `EnemyLevelRange`, который содержит эти значения и любые соответствующие проверки.

## Проблемы сериализации
Сериализация примитивных типов проста, так как поддерживается многими методами сериализации. Однако, когда мы создаем собственные типы, если требуется сериализация, мы должны быть осторожны, так как это может усложнить ситуацию. Распаковка пользовательского типа для выполнения сериализации и наоборот может занять время и усилия разработки.