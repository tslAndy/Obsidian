#oop 
## Разделение команд и запросов
Хорошим способом управлением побочными эффектами является создание четкого разделения команд и запросов. Команда изменяет систему и обладает побочным эффектом. Запрос возвращает вычисленное значение или состояние системы. 


> [!INFO]
> Функции, которые изменяют состояние, не должны возвращать значения, а функции, возвращающие значения, не должны изменять состояние.

## Аргументы
- Длинные списки аргументов в функции крайне трудны для вызываемого кода. К тому же, тогда можно передать аргументы в неправильном порядке с минимальной безопасностью типов и снизить читабельность кода.
- Их трудно прочесть и понять. Приходится дважды проверять сигнатуру функции при каждом вызове.
- Аргументы осложняют тестирование функции. Крайне трудно писать тестовые примеры для корректной работы всех возможных сочетаний аргументов.

Чем лучше функция, тем меньше в ней аргументов. В идеале — их нет.

ниладическая (нулевая) -> монадическая -> диадическая -> триадическая> полиадическая

- Объекты аргумента. Если в функциях вы передаете три и более аргументов, то сядьте и подумайте. Если три и более переменные так тесно связаны, что даже передаются вместе в функцию, то почему бы не превратить их в объект?
- Перегрузка. Перегрузка функции делается для того, чтобы, например, клиент мог вызвать нужную версию функции, указав необходимые параметры.
- [[Строитель +]] или [[Fluent Interface +]]: Иногда перегрузка функции приводит к неожиданному эффекту, более известному как анти-паттерн «Телескопический конструктор». 
- Глобальные перменные - Не рекомендуется. Пожалуй, самым известным и презираемым подходом в разработке ПО с использованием состояния для сокращения параметров в методах является создание глобальных переменных экземпляров. Это решение далеко не идеально, но в ряде случаев работает на ура. Пользуйтесь им с осторожностью, особенно в приложениях с высокой многопоточностью.

## Логические аргументы:
Чаще всего при передаче`boolean`в функцию вы объявляете, что написали функцию, которая выполняет два действия: одно для `true` и одно для `false`. Лучше напишите две функции - по одной на каждый сценарий.

```cs

// какая-то хуета
ProgressDialog.show("title", "message", false, true, listener);

ProgressDialog dialog = new ProgressDialog.Builder()
.SetTitle("title")
.SetMessage("message")
.SetIndeterminate(false)
.SetCancelable(true)
.SetCancelListener(listener)
.build()

```

## Нулевая защита Null
Передавать null в функцию или писать функцию, ожидающую значения null, — также плохо, как передавать логические значения. По сути, даже хуже. Ведь вы даже не уверены в том, что в ней прописано всего лишь два возможных состояния.

## Методы
Код внутри определенного сегмента/блока должен находиться на едином уровне абстракции. Функция, выполняющая свыше одного действия, обладает теми же недочетами, что и длинная функция. Это утверждение становится еще правдивее по мере тестирования кода. Куда проще проверить функцию, выполняющую что-то одно.
