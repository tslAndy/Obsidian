#oop
Каждый компонент должен иметь одну и только одну причину для изменения. Весь функционал должен быть целостным и обладать высокой связанностью (high cohesion). Принцип единственной ответственности не говорит, что каждый класс должен делать только одно дело.

Распространенные сценарии выделения компонентов:
- Логика хранения данных
- Валидация
- Механизм уведомлений пользователя
- Обработка ошибок
- Логгирование
- Выбор класса или создание его объекта
- Форматирование
- Парсинг
- Маппинг данных

## Истоки SRP
Закон Конвея - закон, описывающий, как коммуникационная структура организаций соотносится с системами, которые они проектируют. SRP - прямая аналогия закона Конвея для ПО. 

Любое изменение, которое может произойти в классе, будет иметь источник, и этот источник напрямую связан с пользователями программы. Каждый класс будет иметь связность, относящуюся к отделу организации, которая использует эту часть нашего кода. Пользователи, которые образуют отдел, определяют методы, которые должны быть включены в наши классы.

## Что является причиной для изменения
Причина для изменения определяется людьми, которые играют определенную роль в организации, использующей нашу программу. Это подразумевает, что определенный класс все равно может нарушать SRP, даже если он состоит из поведения, полезного только для людей определенного отдела, если люди в этом отделе выполняют более одной роли. Причина для изменения определяется различными ролями, которые существуют у групп людей, использующих нашу программу.

Итак, причина для изменения не определяется кодом, а определяется требованиями. Кто те люди, которые используют нашу программу, для какой цели и какие у них потребности. Когда у нас есть четкое представление о том, какие группы людей будут использовать нашу программу в организации, какие роли выполняют эти люди и почему каждая группа, которая выполняет одну или несколько ролей, нуждается в нашей программе, тогда мы проектируем наши классы таким образом, чтобы представлять эти группы и роли. Вот почему, когда мы видим один класс без контекста, когда мы не знаем, кто пользователи этого класса, мы не можем сделать вывод, нарушает ли этот класс SRP или нет.

## Пример SRP
Предположим, мы отвечаем за создание программы, которая содержит сотрудников. Это простая программа, которая будет содержать имя сотрудника, работу, которую он в настоящее время выполняет, и его зарплату. Мы можем добавлять или удалять сотрудников, назначать различные работы и иметь отчет, который печатает сотрудников, их текущую работу и их текущую зарплату.

До сих пор у нас не было достаточно информации, чтобы спроектировать наши классы таким образом, чтобы они не нарушали SRP.

Если мы узнаем, что эта программа будет использоваться компанией, в которой есть отдел кадров, отвечающий за найм и увольнение сотрудников, отдел управления, отвечающий за распределение должностей, и бухгалтерский отдел, отвечающий за выплату заработной платы и расчет общей стоимости этой заработной платы, то мы получим представление о том, кто является пользователями нашей программы и как каждая группа пользователей будет ее использовать.

Используя эту информацию, мы проектируем наши классы таким образом, что у каждого класса будет только одна причина для изменения. Методы, которые отвечают за изменение и расчет зарплат, должны находиться в другом классе, чем методы, которые отвечают за назначение рабочих мест. Это также касается методов, которые будут отвечать за добавление или удаление сотрудников.

Всякий раз, когда в нашей программе возникает необходимость внесения изменений, эти изменения будут направлены на нужды отдела, но также будут происходить в классе, который отвечает только за этот отдел.

## Преимущества SRP
Изолируя причины для изменения, мы делаем наш код легким для изменения. Мы не только имеем четкое понимание того, куда нам нужно идти, чтобы внести необходимые изменения, но и можем быть уверены, что это изменение не повлияет на другие части нашей программы.

Например, если необходимо внести изменения в отдел кадров, мы можем быть уверены, что это не повлияет на способ расчета заработной платы, поскольку эти методы существуют в другом классе и не используют общие данные и поведение с классом, который добавляет и удаляет сотрудников.

Даже если мы окажемся в ситуации, когда наши изменения вносят ошибку, эта ошибка будет ограничена функциональностью, необходимой отделу кадров. Если бы мы нарушили SRP, эта ошибка могла бы также повлиять на другой отдел.

## Пример SRP, зависящего от ролей
Поскольку SRP связан с пользователями и их ролями, мы можем обнаружить, что написанная нами программа может внезапно начать нарушать SRP, даже если никакого нового поведения не требуется.

Например, мы могли закодировать программу, которая будет использоваться одним человеком, имеет описание расходов и число, которое представляет стоимость этих расходов. Наш пользователь хочет иметь возможность добавлять/удалять расходы и иметь отчет, отображаемый на экране или распечатанный на бумаге. Мы разделили наши классы таким образом, что класс несет ответственность за создание отчета, а два класса принимают отчет в качестве параметра. Один имеет методы, которые отвечают за отображение этого отчета на экране, а другой имеет методы, которые отвечают за использование принтера для печати этого отчета на бумаге.

Если мы узнаем, что наш пользователь решил, что он будет использовать распечатанный отчет не только для себя, но и для своего бухгалтера, то внезапно наша программа больше не следует SRP. Класс, который отвечает за печать, теперь отвечает за две разные группы людей, которые выполняют разные роли. У этого класса теперь есть две причины для изменения, одна из них — если нашему пользователю нужны какие-либо изменения для себя, а другая — бухгалтер. Хотя потребности пользователя и бухгалтера могут быть одинаковыми в начале, ничто не гарантирует, что эти потребности не разойдутся в будущем.

Наш класс, отвечающий за печать отчета, должен быть разделен на два класса: один отвечает за печать пользовательского отчета, а другой — за печать отчета бухгалтера. Создание двух методов в одном классе, один из которых отвечает за печать отчета для пользователя, а другой — за печать отчета для бухгалтера, также будет нарушением SRP.

Здесь важно то, что, хотя изменение поведения нашей программы не требовалось, изменение нашей архитектуры необходимо, поскольку группы людей, использующих нашу программу, изменились.

## SRP и разработка игр
В разработке игр пользователи нашей программы — это не только игроки игры. Различные группы гейм-дизайнеров, художников, аниматоров, музыкантов, людей, ответственных за создание повествования, даже людей, ответственных за локализацию, следует считать разными отделами.

Классы должны быть сделаны таким образом, чтобы была только одна причина для изменения. Если в нашем коде необходимо изменение, которое повлияет на игровую механику, это изменение не должно быть в классе, который также отвечает за анимацию, звуковые эффекты или даже за отображение диалогов на экране.

Даже если игра сделана небольшой командой или даже разработчиком-одиночкой, эти люди выполняют разные роли. Пока классы следуют SRP, изменения легче кодировать, и любые ошибки будут оставаться изолированными для соответствующего отдела. Это позволит быстрее внедрять любые будущие изменения, которые нам могут понадобиться, но также устранит любой страх изменения нашего кода, который может существовать, из-за того, что это изменение приведет к изменениям или ошибкам в не связанных частях программы