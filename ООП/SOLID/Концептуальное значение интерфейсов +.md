#oop
Наследование — это базовая концепция ООП. Класс, обычно называемый дочерним или производным классом, наследует данные и поведение другого класса, обычно называемого базовым или родительским классом.

В других языках существует концепция множественного наследования . Класс может наследовать данные и поведение от нескольких родительских классов. Это может создать проблему ромбовидного наследования. 

Интерфейсы — это способ в C#, с помощью которого мы можем наследовать от нескольких классов, если только один из этих классов предоставляет реализации.

Итак, почему в C# разрешено реализовывать несколько интерфейсов, но запрещено наследоваться от нескольких классов?

## Интерфейсы как контракт
Интерфейсы это контракт между классом, который реализует интерфейс, и классом, который его использует

Примером контракта в реальном мире является контракт между работодателем и сотрудником. Контракт описывает, что должен делать сотрудник. Например писать код, готовить, смотреть фильмы и писать посты в блоге, но работодателю все это безразлично. Его волнует только то, что сотрудник умеет писать код. У него есть компания, которая ищет человека, который умеет писать код, поэтому он создает требования и описывает их в статье. Все остальное, что сотрудник умеет делать, не является частью этих требований, поскольку работодателю они не нужны.

С другой стороны, работодателю все равно, как сотрудник будет что-то кодировать. Очевидно, его волнует, чтобы сотрудник делал это правильно, но то, как он это сделает, определяет он сам, пока конечный результат соответствует требованиям, описанным в контракте.

Работодатель — класс, который использует контракт. Сотрудник — класс, который реализует этот контракт. Контракт не описывает все, что сотрудник может делать, а только то, что представляет интерес для работодателя.

Хотя сотрудник тот, кто реализует контракт, тот, кто отвечает за его составление, очевидно, работодатель. Сотрудник не ищу работу и не говорит: «Привет, я здесь, чтобы кодить, готовить и смотреть фильмы». Работодатель говорит, что он ищет кого-то, кто умеет кодить, и его интересуют только мои навыки кодирования.

Концептуально договор принадлежит скорее работодателю, который несет ответственность за его составление, чем сотруднику, и сотрудник несет ответственность за его реализацию.

То же самое верно и для нашего кода. Концептуально интерфейс принадлежит классу или системе, которые его используют, а не классу или классам, которые его реализуют.

## Пример контракта
Предположим, что у нас есть враги в игре, которые при атаке дают игроку предупреждение. У нас может возникнуть соблазн сделать что-то вроде этого:

```cs
public interface IPlayer
{
   void EnemyAttackWarning();
}

public class Player : IPlayer
{
   public void EnemyAttackWarning() => Console.WriteLine("An Enemy is Attacking!");
}

public class Enemy
{
   private readonly IPlayer _player;

   public Enemy(IPlayer player) => _player = player;

   public void Attack()
   {
      // Enemy attack code
      _player.EnemyAttackWarning();
   }
}
```

Проблема здесь в том, что закодированный таким образом интерфейс `IPlayer` концептуально ближе к классу `Player`, чем к классу `Enemy`.

Мы можем иметь тот же код с одним небольшим изменением. Мы должны переименовать интерфейс `IPlayer` во что-то более подходящее, что концептуально ближе к `Enemy` и дает читателю лучшее понимание его цели.

Например, мы могли бы назвать его `IEnemyWarnings`. Код может быть тем же самым, но есть большая разница: если требования к предупреждениям об атаках противника изменятся, единственное, что нам нужно будет сделать, это реализовать интерфейс в соответствующем классе `IEnemyWarnings`.

Например, если бы мы когда-нибудь решили, что NPC должен выдавать предупреждение, то класс, представляющий наших NPC, реализовал бы интерфейс, а если бы позже мы решили, что свет в нашем пользовательском интерфейсе начнет мигать при атаке врага, то класс, обладающий функциональностью света, реализовал бы интерфейс `IEnemyWarnings`.

С помощью фабрики, которая создает экземпляры `IEnemyWarnings` с этим интерфейсом, любые изменения в нашей программе станут тривиальными. Мы внедрим во вражеский класс соответствующую реализацию, получив ее из фабрики. Наш интерфейс концептуально более тесно связан с классом, который его использует, классом `Enemy`, чем с классом, который каждый раз его реализует. Имя должно представлять эту связь, и это упростит любые будущие изменения, поскольку требуемый класс реализует его.

## Абстракция: что может делать объект против того, что объект представляет
Приведенный выше пример показывает еще одно различие между интерфейсами, которые являются абстракциями, и классами, имеющими реализации.

> Интерфейс показывает, что класс может делать, в то время как реализация показывает, что класс собой представляет.

Придерживаясь вышеизложенной концепции, некоторые проблемы легче решать. Например, предположим, что у нас есть инвентарь, который может содержать любое количество предметов. Поскольку в нашей игре много предметов, у нас также есть контейнеры, которые игрок может иметь в своем инвентаре, и каждый контейнер также может содержать любое количество предметов. Следуя этой логике, внутри каждого контейнера мы можем иметь предметы или другие контейнеры, которые в свою очередь также могут иметь предметы или контейнеры внутри и так далее.

```cs
public interface IItem
{
   string Description { get; }
}

public class Item : IItem
{
   public string Description { get; }
   public Item(string description) => Description = description;
}
```

```cs
public class Container : List<IItem>, IItem
{
   public string Description { get; }
   public Container(string description) => Description = description;
}
```

Теперь наш `Container` может содержать `IItems`, но также сам является типом `IItem` , поэтому его можно размещать внутри других контейнеров. Это означает, что если у нас есть игрок, у которого есть инвентарь, который является типом `Container`:

```cs
public class Player
{
   public Container Inventory { get; } = new("The player inventory");

   private string _indent = "";
   public void ShowAllInventoryItems() => ShowContainerItems(Inventory);

   private void ShowContainerItems(Container container)
   {
      foreach (IItem item in container)
      {
         Console.Write($"{_indent}{item.Description}");

         if (item is Container { Count: > 0 } nestedContainer)
         {
            _indent += "   ";
            Console.WriteLine(" that contains: ");
            ShowContainerItems(nestedContainer);
            _indent = _indent.Remove(_indent.Length - 3, 3);
         }
         else
         {
            Console.WriteLine();
         }
      }
   }
}
```

Мы можем сделать:

```cs
Player player = new Player();

IItem stone = new Item("Small stone");
Container bagOfGuns = new Container("Bag of Guns");
Container gun = new Container("Small gun");
Container machineGun = new Container("Machine gun");
Container bagOfAmmo = new Container("Ammo bag");
IItem gunBullets = new Item("Some gun Bullets");
IItem machineGunBullets = new Item("Some machine gun Bullets");

player.Inventory.Add(stone);
player.Inventory.Add(bagOfGuns);

bagOfGuns.Add(gun);
bagOfGuns.Add(machineGun);
bagOfGuns.Add(bagOfAmmo);

bagOfAmmo.Add(gunBullets);
bagOfAmmo.Add(machineGunBullets);
```

Вызвав метод `player.ShowAllInventoryItems()` мы можем увидеть:
```
Small stone
Bag of Guns that contains:
   Small gun
   Machine gun
   Ammo bag that contains:
      Some gun Bullets
      Some machine gun Bullets
```

Теперь мы можем легко извлечь пули из нашего контейнера с боеприпасами и добавить их в наше оружие, поскольку оружие также является контейнером:

```cs
bagOfAmmo.Remove(gunBullets);
gun.Add(gunBullets);
```

Наш класс `Items` здесь является общим, но в игре предметом может быть что угодно. Например, яблоко будет представлено классом `Apple`, который будет реализовывать `IItem`интерфейс, а также некоторые другие интерфейсы (напр. `IConsumable`), наши пули, вероятно, будут иметь свои собственные реализации, но также будут реализовывать интерфейс `IItem`и т. д.

Абстракции определяют, что может делать нечто, в данном случае и элементы, и контейнеры могут делать то же, что и элементы: иметь описание.

Напротив, реализации определяют, что представляет класс: Наш класс `Item` представляет элементы, а наш класс `Container` представляет контейнеры, которые могут содержать элементы, но также иметь функциональность `item`'ов. Контейнеры, однако, не являются элементами, но имеют функциональность, которая определяется в интерфейсе `IItem`, и ей должны обладать наши элементы, чтобы они могли использоваться в качестве элементов нашими системами.

## Пример контейнера для воды
В игре ведро — это предмет, который имеет функциональность интерфейса `IItem`, но также может содержать воду. Вместо того, чтобы сделать функциональность хранения воды частью реализации ведра, например, добавить воду, удалить воду и получить максимальное количество воды, мы могли бы создать интерфейс `IWaterContainer`. 

При таком интерфейсе любая система, отвечающая за использование ведра для выполнения каких-либо действий с имеющейся в нем водой, не должна будет ничего знать о ведре, а будет знать только об интерфейсе `IWaterContainer`.

Это позволило бы нам вносить изменения в будущем проще. Например, одеяло в нашей игре также могло бы реализовать интерфейс `IWaterContainer`, чтобы оно могло удерживать небольшое количество воды, которое представляет, что оно мокрое. Это одеяло можно было бы использовать из системы, которая отвечает за использование воды, имеющейся в предмете, поскольку наша система теперь не зависит от реализаций, а заботится только об интерфейсе `IWaterContainer`, который определяет, что объект может делать, а не то, что он представляет.