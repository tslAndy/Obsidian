#oop
Должна быть возможность вместо базового типа подставить любой его подтип.

Рассмотрим пример квадрата и прямоугольника:
```cs
class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }
     
    public int GetArea()
    {
        return Width * Height;
    }
}
 
class Square : Rectangle
{
    public override int Width
    {
        get
        {
            return base.Width;
        }
 
        set
        {
            base.Width = value;
            base.Height = value;
        }
    }
 
    public override int Height
    {
        get
        {
            return base.Height;
        }
 
        set
        {
            base.Height = value;
            base.Width = value;
        }
    }
}
```

И в подобном коде получим ошибку:
```cs
class Program
{
    static void Main(string[] args)
    {
        Rectangle rect = new Square();
        TestRectangleArea(rect);
 
        Console.Read();
    }
 
    public static void TestRectangleArea(Rectangle rect)
    {
        rect.Height = 5;
        rect.Width = 10;
        if (rect.GetArea() != 50)
            throw new Exception("Некорректная площадь!");
    }
}
```

Как вариант используется вариант с тестом на принадлежность к типу:
```cs
public static void TestRectangleArea(Rectangle rect)
{
    if(rect is Square)
    {
        rect.Height = 5;
        if (rect.GetArea() != 25)
            throw new Exception("Неправильная площадь!");
    }
    else if(rect is Rectangle)
    {
        rect.Height = 5;
        rect.Width = 10;
        if (rect.GetArea() != 50)
            throw new Exception("Неправильная площадь!");
    }
}
```

Но такое решение подчеркивае несовершенство архитектуры. Проблема в том, что класс Square не ведет себя как базовый класс Rectangle, поэтому его не стоит наследовать от него. 

Есть несколько типов правил, которые должны быть соблюдены для выполнения принципа подстановки Лисков. 

Правило контракта. Контракт представляет собой некоторый интерфейс базового класса, некоторые соглашения по его использованию, которым должен следовать класс-наследник. Контракт задает ряд ограничений или правил, и прозиводный класс должен их выполнять.

## Предусловия (Preconditions) не могут быть усилены в подклассе. 
Предусловия представляют набор условий, необходимых для безошибочного выполнения метода. Например:
```cs
public virtual void SetCapital(int money)
{
    if (money < 0)
        throw new Exception("Нельзя положить на счет меньше 0");
    this.Capital = money;
}
```

Причем объектом предусловий могут быть только общедоступные свойства или поля класса или параметры метода, как в данном случае. Приватное поле не может быть объектом для предусловия, так как оно не может быть установлено из вызывающего кода. Например, в следующем случае условное выражение не является предусловием:
```cs
private bool isValid = false
public virtual void SetCapital(int money)
{
    if (isValid == false)
        throw new Exception("Валидация не пройдена");
    this.Capital = money;
}
```

Теперь, допустим, есть два класса: Account (общий счет) и MicroAccount (мини-счет с ограничениями). И второй класс переопределяет метод SetCapital:
```cs
class Account
{
    public int Capital { get; protected set; }
         
    public virtual void SetCapital(int money)
    {
        if (money < 0)
            throw new Exception("Нельзя положить на счет меньше 0");
        this.Capital = money;
    }
}
 
class MicroAccount : Account
{
    public override void SetCapital(int money)
    {
        if (money < 0)
            throw new Exception("Нельзя положить на счет меньше 0");
 
        if (money > 100)
            throw new Exception("Нельзя положить на счет больше 100");
 
        this.Capital = money;
    }
}
```

В этом случае подкласс `MicroAccount` добавляет дополнительное предусловие, то есть усиливает его, что недопустимо. Поэтому в реальной задаче мы можем столкнуться с проблемой:

```cs
class Program
{
    static void Main(string[] args)
    {
        Account acc = new MicroAccount();
        InitializeAccount(acc);
 
        Console.Read();
    }
 
    public static void InitializeAccount(Account account)
    {
        account.SetCapital(200);
        Console.WriteLine(account.Capital);
    }
}
```

С точки зрения класса Account метод `InitializeAccount()` вполне является работоспособным. Однако при передаче в него объекта `MicroAccount` мы столкнемся с ошибкой. В итоге пинцип Лисков будет нарушен.

## Постусловия (Postconditions) не могут быть ослаблены в подклассе. 
То есть подклассы должны выполнять все постусловия, которые определены в базовом классе. Постусловия проверяют состояние возвращаемого объекта на выходе из функции. Например:

```cs
public static float GetMedium(float[] numbers)
{
    if (numbers.Length == 0)
        throw new Exception("длина массива равна нулю");
 
    float result = numbers.Sum() / numbers.Length;

	// постусловие
    if(result <0)
        throw new Exception("Результат меньше нуля");
    return result;
}
```

Пример нарушения:
```cs
class Account
{
    public virtual decimal GetInterest(decimal sum,  int month, int rate)
    {
        // предусловие
        if (sum < 0 || month >12 || month <1 || rate <0)
            throw new Exception("Некорректные данные");
 
        decimal result = sum;
        for (int i = 0; i < month; i++)
            result += result * rate  / 100;
 
        // постусловие
        if (sum >= 1000)
            result += 100; // добавляем бонус
 
        return result;
    }
}
 
class MicroAccount : Account
{
    public override decimal GetInterest(decimal sum, int month, int rate)
    {
        if (sum < 0 || month > 12 || month < 1 || rate < 0)
            throw new Exception("Некорректные данные");
 
        decimal result = sum;
        for (int i = 0; i < month; i++)
            result += result * rate /100;
 
        return result;
    }
}
```

В качестве постусловия в классе Account используется начисление бонусов в 100 единиц к финальной сумме, если начальная сумма от 1000 и более. В классе `MicroAccount` это условие не используется.

 Мы можем столкнуться с проблемой с данными классами:
 ```cs
class Program
{
    public static void CalculateInterest(Account account)
    {
        decimal sum = account.GetInterest(1000, 1, 10); // 1000 + 1000 * 10 / 100 + 100 (бонус)
        if(sum!=1200) // ожидаем 1200
        {
            throw new Exception("Неожиданная сумма при вычислениях");
        }
    }
    static void Main(string[] args)
    {
        Account acc = new MicroAccount();
        CalculateInterest(acc); // получаем 1100 без бонуса 100
 
        Console.Read();
    }
}
```

## Инварианты (Invariants) — все условия базового класса - также должны быть сохранены и в подклассе
Инварианты - это некоторые условия, которые остаются истинными на протяжении всей жизни объекта. Как правило, инварианты передают внутреннее состояние объекта.
```cs
class User
{
    protected int age;
    public User(int age)
    {
        if(age<0)
            throw new Exception("возраст меньше нуля");
 
        this.age = age;
    }
 
    public int Age
    {
        get { return age; }
        set
        {
            if (value < 0)
                throw new Exception("возраст меньше нуля");
            this.age = value;
        }
    }
}
```

Поле `age` выступает инвариантом. И поскольку его установка возможна только через конструктор или свойство, то в любом случае выполнение предусловия и в конструкторе, и в свойстве гарантирует, что возраст не будет меньше 0. И данное объектоятельство сохранит свою истинность на протяжении всей жизни объекта `User`.

Теперь рассмотрим, как здесь может быть нарушен принцип Лисков. Пусть у нас будут следующие два класса:
```cs
class Account
{
    protected int capital;
    public Account(int sum)
    {
        if(sum<100)
            throw new Exception("Некорректная сумма");
        this.capital = sum;
    }
 
    public virtual int Capital
    {
        get { return capital; }
        set
        {
            if (value < 100)
                throw new Exception("Некорректная сумма");
            capital = value;
        }
    }
}
 
class MicroAccount : Account
{
    public MicroAccount(int sum) : base(sum)
    {
    }
 
    public override int Capital
    {
        get { return capital; }
        set
        {
            capital = value;
        }
    }
}
```

С точки зрения класса `Account` поле не может быть меньше 100, и в обоих случаях, где идет присвоение - в конструкторе и свойстве это гарантируется. А вот производный класс `MicroAccount`, переопределяя свойство `Capital`, этого уже не гарантирует. Поэтому инвариант класса Account нарушается.

Во всех трех вышеперечисленных случаях проблема решается в общем случае с помощью абстрагирования и выделения общего функционала, который уже наследуют классы `Account` и `MicroAccount`. То есть не один из них наследуется от другого, а оба они наследуются от одного общего класса.

## Пример интерфейса `INPC`
Хотя интерфейс не содержит никаких поведений, поскольку поведения определены в классах, которые реализуют интерфейс, мы все равно можем нарушить LSP. Это может произойти, когда два разных класса, которые реализуют интерфейс, изменяют поведение того, как реагирует наша программа, в своих реализациях.

Это не значит, что все классы, реализующие метод из интерфейса, должны иметь, очевидно, один и тот же код. Существует разница между тем, что делает метод, и тем, как он это делает. Нарушение LSP происходит, когда классы делают разные вещи с одним и тем же методом, а не когда они делают одно и то же по-разному.

Вот пример. Предположим, что в игре есть NPC, и эти NPC могут разговаривать с персонажем игрока или атаковать его. Каждый NPC, используя метод, `Talk`может делать разные вещи, например, он может дать игроку квест или открыть инвентарь, чтобы покупать и продавать предметы. То же самое относится и к методу `Attack`: один NPC может обидеться, когда игрок что-то говорит, и атаковать в ближнем бою, другой NPC может начать использовать дистанционные атаки, когда персонаж игрока пытается украсть у него.

```cs
public interface INpc
{
   void Talk(Character target);
   void Attack(Character target);
}
```

Через некоторое время мы получаем возможность создать нового NPC. Магическое дерево, которое может только давать квесты игроку, оно никогда не может атаковать его. Поэтому мы решили вывести его из интерфейса `INpc`и оставить `Attack`метод пустым. В конце концов, это требование, магическое дерево не совершает атак.

Проходит время, и через пару лет мы приближаемся к завершению нашей игры. Игрок наконец-то нашел проклятую книгу, которую искал, и он должен вернуть ее в храм. Конечно, его предупреждают, что он никогда не должен открывать книгу, иначе он обречен.

Ну, мы знаем, что есть большая вероятность, что игрок попытается открыть книгу, поэтому мы решили, что если он это сделает, мы заморозим управление игроком, и все NPC вокруг него начнут взламывать, пока он не умрет. Он не должен был этого делать, поэтому пришло время перезагрузиться с последнего сохранения.

Есть ошибка. 

Если игрок открывает проклятую книгу перед магическим деревом, когда вокруг нет других NPC, игрок управляет заморозкой, и система, которая отвечает за атаки, будет продолжать вызывать метод `INpc.Attack`, но этот метод пуст для дерева. Наша игра зависнет. Игрок не сможет двигаться и не умрет, потому что метод `Attack`имеет поведение, отличное от ожидаемого. Он не атакует игрока, он ничего не делает.

Решение здесь все еще остается беспорядком. Даже если мы найдем ошибку, а не наших игроков (что было бы сложно, так как нам пришлось бы вспомнить через пару лет, что есть NPC, что его атака на самом деле не атака, но она ничего не делает), нам все равно пришлось бы создавать зависимости от системы, которая отвечает за управление атаками, к конкретной реализации, магическому дереву.

Внезапно система, которая была отделена от остальной части нашей программы и зависела только от абстракции интерфейса `INpc`, будет иметь операторы if, которые проверяют тип каждого экземпляра `INpc`, и если это тип `MagicalTree`, то делают что-то еще, например, игнорируют атаку. Теперь наша система зависит от класса `MagicalTree`. Любые изменения в этом классе могут повлиять на несвязанную систему, систему, которая отвечает за атаку с использованием интерфейса `INpc`.

Оставив `INpc.Attack`пустым, мы нарушили LSP. Лучшим способом было бы создать два интерфейса, например, интерфейс `INpcTalk`, который имеет все методы, отвечающие за разговор, и `INpcAttack`интерфейс, который имеет все методы, отвечающие за атаку. Таким образом, когда мы создавали класс `MagicalTree`, мы бы заставили его реализовать только интерфейс `INpcTalk`, а система, отвечающая за атаку, использовала бы только `INpcAttack`интерфейс. Это на самом деле часть  [[Interface Segregation Principle +]].

