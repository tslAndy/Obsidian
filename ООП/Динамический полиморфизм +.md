#oop 

Полиморфизм позволяет нам использовать объекты различных типов через один и тот же интерфейс. В C# мы сталкиваемся с тремя основными формами полиморфизма: перегрузка методов и операторов, обобщения и переопределение методов.

## Перегрузка методов и операторов
```cs
public class BasketOfFlowers
{
   private int _amount;

   public BasketOfFlowers(int amount) => _amount = amount;

   public void Add(int amount) => _amount += amount;

   public void Add(BasketOfFlowers basketOfFlowers) => _amount += basketOfFlowers._amount;

   public static bool operator ==(BasketOfFlowers basketOfFlowers1, BasketOfFlowers basketOfFlowers2)
   {
      return basketOfFlowers1._amount == basketOfFlowers2._amount;
   }

   public static bool operator !=(BasketOfFlowers basketOfFlowers1, BasketOfFlowers basketOfFlowers2)
   {
      return !(basketOfFlowers1 == basketOfFlowers2);
   }
}

```

## Метод переопределения
Несмотря на то, что у нас есть интерфейс`IEnemy`, результат вызова `Attack` зависит от конкретной реализации:

```cs
public interface IEnemy
{
   void Attack();
}

public class Skeleton : IEnemy
{
   public void Attack()
   {
      Console.WriteLine("The Skeleton Attacks");
   }
}

public class Goblin : IEnemy
{
   public void Attack()
   {
      Console.WriteLine("The Goblin Attacks");
   }
}

```

Тот же принцип применяется к наследованию от конкретного базового класса с использованием ключевых слов `abstract`, `virtual` и `override`:

```cs
public abstract class Parent
{
   public abstract void Method1();

   public virtual void Method2() => Console.WriteLine("Method2 of Parent");
}

public class FirstChild : Parent
{
   public override void Method1() => Console.WriteLine("Method 1 of FirstChild");

   public override void Method2()
   {
      Console.WriteLine("Method 2 of FirstChild");
   }
}

public class SecondChild : Parent
{
   public override void Method1() => Console.WriteLine("Method 1 of SecondChild");

   public override void Method2()
   {
      base.Method2();
      Console.WriteLine("Method 2 of SecondChild");
   }
}
```

## Дженерики
Мы также можем использовать статический полиморфизм, используя дженерики и шаблон [[Curiously Recurring Template +]]

## Данные против логики
```cs
public class Enemy
{
   public void Attack(string message) => Console.WriteLine(message);
}
```

Единственное различие между нашим Скелетом и Гоблином — это напечатанное сообщение. Можно утверждать, что этот подход требует предоставления сообщения в качестве параметра каждый раз. Более подходящий способ записать пример `IEnemy`был бы следующим:

```cs
public class Enemy(string attackMessage)
{
   public void Attack() => Console.WriteLine(attackMessage);
}

Enemy goblin = new Enemy("The Goblin Attacks");
Enemy skeleton = new Enemy("The Skeleton Attacks");
```

Полиморфизм подразумевает общий интерфейс для различных типов, но типы определяются их поведением, а не данными. Если два реальных объекта обладают идентичным поведением, но разными данными, они принадлежат к одному и тому же типу, что делает полиморфизм ненужным.

```cs
public interface IEnemy
{
   int HitPoints { get; set; }
   int AttackDamage { get; set; }
   void Attack(IEnemy enemy);
}

public class Skeleton : IEnemy
{
   public int HitPoints { get; set; } = 50;
   public int AttackDamage { get; set; } = 30;

   public void Attack(IEnemy enemy)
   {
      Console.WriteLine($"The Skeleton Attacks the {enemy}");
      enemy.HitPoints -= AttackDamage;
   }
}

public class Goblin : IEnemy
{
   public int HitPoints { get; set; } = 100;
   public int AttackDamage { get; set; } = 20;

   public void Attack(IEnemy enemy)
   {
      Console.WriteLine($"The Goblin Attacks the {enemy}");
      enemy.HitPoints -= AttackDamage;
   }
}
```

Как видно, это все не нужно, и можно сделать следующим образом:

```cs
public class Enemy(string attackMessage, int hitPoints, int attackDamage)
{
   public int HitPoints { get; private set; } = hitPoints;

   public void Attack(Enemy enemy)
   {
      Console.WriteLine(attackMessage);
      enemy.HitPoints -= attackDamage;
   }
}

Enemy goblin = new Enemy("The Goblin Attacks", 50, 30 );
Enemy skeleton = new Enemy("The Skeleton Attacks", 100, 20);
```

## Представление различных типов
Первое соображение заключается в том, что нам действительно может потребоваться определенный тип врага, который у нас есть. В нашем примере мы не можем указать, какой враг подвергается атаке каждый раз, поскольку все враги принадлежат к одному типу `Enemy`. Однако это не означает, что нам нужно создавать новые типы (классы) для размещения этой информации. Такая информация просто представляет собой еще один фрагмент данных, а не изменение поведения.

```cs
public enum EnemyType
{
   Goblin,
   Skeleton
}

public class Enemy(string attackMessage, int hitPoints, int attackDamage, EnemyType enemyType)
{
   public int HitPoints { get; private set; } = hitPoints;
   private EnemyType EnemyType { get; } = enemyType;

   public void Attack(Enemy enemy)
   {
      Console.WriteLine($"{attackMessage} the {enemy.EnemyType}");
      enemy.HitPoints -= attackDamage;
   }
}
```

Несколько замечаний:
- Метод `Attack` публичный, а полу `EnemyType` приватное, тем не менее все работает, так как инкапсуляция `EnemyType` служит для инкапсуляции типов, а не объектов. 
- Сейчас легко изменить тип врага в реальном времени, можно просто сделать поле `EnemyType` публичным, и это намного проще, чем если бы нам пришлось менять тип класса.

## Фабрика
Фабрика может быть полезна не только для генерации конкретных реализаций наших абстракций, но и для создания объектов со стандартными данными.

Рассмотрим сценарий, в котором все наши гоблины в предыдущем примере обладают одинаковым сообщением и хит-пойнтами, но различаются по урону от атаки. В таких случаях фабрика могла бы автоматизировать этот процесс для нас:

```cs
public static class EnemyFactory
{
   public static Enemy CreateGoblin(int attackDamage) =>
      new Enemy("The Goblin Attacks", 50, attackDamage, EnemyType.Goblin);
   
   public static Enemy CreateSkeleton(int attackDamage) =>
   new Enemy("The Skeleton Attacks", 100, attackDamage, EnemyType.Skeleton);
}

Enemy goblin = EnemyFactory.CreateGoblin(30);
Enemy skeleton = EnemyFactory.CreateSkeleton(20);
```