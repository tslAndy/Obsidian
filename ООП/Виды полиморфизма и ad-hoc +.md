#oop 
Есть три вида:
- Параметрический
- Специальный (ad-hoc)
- Полиморфизм подтипов

**Параметрический полиморфизм**. Допустим, у нас есть список элементов. Это может быть список целых чисел, чисел с плавающей запятой, строк, чего угодно. Теперь представьте метод `GetHead()`, который возвращает первый элемент из этого списка. Для него не важно, является ли возвращаемый элемент типом `int`, `string`, `Apple` или `Orange`. Его возвращаемый тип — это формальный типовой параметр, стоящий вместо `T` внутри `IList<T>`, и его реализация одинакова для всех типов: «вернуть первый элемент».
```cs
interface IList<T>
{
    T GetHead();
}
```

**Специальный полиморфизм** привязан к типу. В зависимости от него вызываются разные реализации метода. Перегрузка методов — один из примеров ad-hoc-полиморфизма. Например, можно иметь две версии метода, присоединяющего первый элемент ко второму — одну, которая принимает два целых числа и складывает их, и другую, которая принимает две строки и конкатенирует их.

```cs
class Appender
{
    public int AppendItems(int a, int b) =>
        a + b;

    public string AppendItems(string a, string b) =>
        $"{a}{b}";
}
```

**Полиморфизм подтипов**. Дочерние классы предоставляют разные реализации метода некоторого базового класса. В отличие от специального полиморфизма, где решение о том, какая реализация вызывается, принимается на этапе компиляции (раннее связывание), в полиморфизме подтипов оно принимается во время выполнения (позднее связывание).

```cs
abstract class Animal
{
    public abstract int GetMeatMass();
}

class Cow : Animal
{
    public override int GetMeatMass() => 20;
}

class Dog : Animal
{
    public override int GetMeatMass() => 5;
}
```

Предположим, мы хотим иметь только один метод (можем назвать его `AppendItems()`), и хочется, чтобы этот метод принимал два «присоединяемых» элемента. Если вызывается с целыми числами, они должны быть присоединены с использованием арифметического сложения. Если вызывается со строками, они должны быть присоединены с использованием конкатенации. Можно придумать реализации для различных других типов, но для нашего примера `int` и `string` будет достаточно.

Конечно, есть вариант решить задачу «в лоб» — писать перегрузку на каждый тип данных, однако хотелось бы заставить компилятор помогать нам, не создавая 100500 методов.

```cs
class Appender
{
    public int AppendItems(int a, int b) =>
        a + b;

    public string AppendItems(string a, string b) =>
        $"{a}{b}";

    public bool AppendItems(bool a, bool b) =>
        a || b;
}
```

Обратите внимание, что метод должен иметь всего одну реализацию — без перегрузки или переопределения! Как же он может выполнять разные операции для разных типов? Итак, идея заключается в том, что метод `AppendItems()` даже не должен знать, как реализована операция присоединения; он должен просто её вызвать. Вот сам метод:

```cs
class Appender
{
    T AppendItems<T>(T a, T b) => a.Append(b);
}
```

Это пример утиной типизации - нам не важно, что это за классы мы соединяем, все, что нам нужно знать - это то, что они соединяются.

Конечно, метод выше не cкомпилируется, так как у обобщённого типа `T` нет метода `Append()`. Есть два подхода к решению этой проблемы — контейнерные типы и паттерн type class.

## Контейнерные типы
```cs
class Appender
{
    public T AppendItems<T>(AppendableValue<T> a, AppendableValue<T> b) =>
        a.Append(b);
}
```

Ладно, метод `AppendItems()` получен. Перейдём к типу `AppendableValue<T>`.
Во-первых, `AppendableValue<T>` будет абстрактным классом. Прежде всего, достаточно удобно использовать абстрактный класс для реализации контейнерного типа, в случае если нужно передать некоторые параметры в конструктор базового класса, некоторый код на C# унаследует его и так далее.

Во-вторых, `AppendableValue<T>` будет параметризован — у него будет формальный типовой параметр. Потому что его операция `Append()` (*не путать с нашим методом* `AppendItems()`!) является обобщённой. Она будет реализована по-разному для разных типов, в нашем случае как сложение для целых чисел и как конкатенация для строк. Поскольку метод `Append()` зависит от типа, весь абстрактный класс зависит от типа. Обратите внимание, что если бы он не зависел от типа, то это был бы случай параметрического полиморфизма, но так как зависит, это случай специального полиморфизма.

```cs
abstract class AppendableValue<T>
{
    public T Value { get; }

    protected AppendableValue(T value) =>
        Value = value;

    public abstract T Append(AppendableValue<T> item);
}
```

```cs
class AppendableIntValue :
    AppendableValue<int>
{
    public AppendableIntValue(int value) :
        base(value) { }

    public override int Append(AppendableValue<int> item) =>
        Value + item.Value;
}

class AppendableStringValue :
    AppendableValue<string>
{
    public AppendableStringValue(string value) :
        base(value) { }

    public override string Append(AppendableValue<string> item) =>
        $"{Value}{item.Value}";
}
```

```cs
var appender = new Appender();
Console.WriteLine(
    appender.AppendItems(
        new AppendableIntValue(1),
        new AppendableIntValue(2)));
Console.WriteLine(
    appender.AppendItems(
        new AppendableStringValue("1"),
        new AppendableStringValue("2")));

```

## Паттерн Type Class
Самый простой способ описать его с точки зрения того, что мы уже знаем на данный момент, заключается в том, что вместо упаковки значений в контейнерные типы `AppendableIntValue` и `AppendableStringValue` для выполнения операции над ними, сами типы бы предлагали возможность выполнить операцию над ними. По сути, это есть отделение данных от операции.

Близким был бы такой код, но он невозможен в C#, так как классы типа не представляют собой существующую структуру в шарпе и ее надо моделировать.
```cs
class Appender
{
    public T AppendItems<IAppendable<T>>(T a, T b) =>
        IAppendable.Append(a, b);
}
```

Обычно это делается через определение интерфейса класса типа, который реализуют для различных конкретных типовых параметров.

```cs
interface IAppendable<T>
{
    T Append(T a, T b);
}

struct AppendableInt : IAppendable<int>
{
    public int Append(int a, int b) =>
        a + b;
}

struct AppendableString : IAppendable<string>
{
    public string Append(string a, string b) =>
        $"{a}{b}";
}
```

Одна из хороших вещей о type class заключается в том, что легко расширять библиотеки, не имея доступа к их исходному коду. Например, при желании поддерживать какие-то типы, отличные от `int` и `string`, нужно лишь предоставить новые реализации для этих типов. Помимо этого, можно не только предоставить реализации для новых типов, но и переопределить реализации для существующих типов, например, чтобы присоединять целые числа с использованием умножения вместо сложения.

```cs
struct AppendableIntMultiplicative : IAppendable<int>
{
    public int Append(int a, int b) =>
        a * b;
}
```

Дальше встаёт вопрос: каким образом нужно доработать метод `AppendItems()`, чтобы использовать интерфейс `IAppendable<T>`? Как вы могли заметить, все реализации интерфейса созданы в виде структур, используя ключевое слово `struct`. Это позволяет в обобщённой среде создавать экземпляры таких объектов, используя оператор `default` и zero cost allocation. То есть создание экземпляра присоединяемого type class ничего не стоит! Правда, за это нужно использовать два формальных типовых параметра.

```cs
class Appender
{
    public T AppendItems<TAppendable, T>(T a, T b)
        where TAppendable : struct, IAppendable<T> =>
        default(TAppendable).Append(a, b);
}



Console.WriteLine(appender.AppendItems<AppendableInt, int>(1, 2));
Console.WriteLine(appender.AppendItems<AppendableString, string>("1", "2"));
```