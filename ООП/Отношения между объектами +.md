#oop 
## Наследование
Определяет отношение **IS A**:

```cs
class User
{
    public int Id { get; set; }
    public string Name { get; set; }
}
 
class Manager : User
{
    public string Company{ get; set; }
}
```

## Реализация
Предполагает определение интерфейса и его реализация в классах:

```cs
public interface IMovable
{
    void Move();
}

public class Car : IMovable
{
    public void Move()
    {
        Console.WriteLine("Машина едет");
    }
}
```

## Ассоциация
Отношение, при котором объекты одного типа неким образом связаны с объектами другого типа. Например, объект одного типа содержит или использует объект другого типа. Агрегация и композиция являются частными случаями ассоциации.

```cs
class Team
{
 
}
class Player
{
    public Team Team { get; set; }
}
```

## Композиция
Определяет отношение **HAS A**. При этом класс автомобиля полностью управляет жизненным циклом объекта двигателя. При уничтожении объекта автомобиля в области памяти вместе с ним будет уничтожен и объект двигателя. И в этом плане объект автомобиля является главным, а объект двигателя - зависимой.

```cs
public class ElectricEngine
{ }
 
public class Car
{
    ElectricEngine engine;
    public Car()
    {
        engine = new ElectricEngine();
    }
}
```

## Агрегация
Она также предполагает отношение **HAS A**, но реализуется она иначе:
```cs
public abstract class Engine
{ }
 
public class Car
{
    Engine engine;
    public Car(Engine eng)
    {
        engine = eng;
    }
}
```

При агрегации реализуется слабая связь, то есть в данном случае объекты Car и Engine будут равноправны. В конструктор Car передается ссылка на уже имеющийся объект Engine. И, как правило, определяется ссылка не на конкретный класс, а на абстрактный класс или интерфейс, что увеличивает гибкость программы.

## Параметризация
В C# это известно как generics. Преимущество generics в том, что он позволяет иметь тип, который не определяет используемые им типы.

Как и в случае с наследованием, параметризация не может изменяться во время выполнения, но в отличие от наследования она может изменять типы, используемые классом, во время компиляции.

Преимущество параметризации в C# заключается в том, что при использовании типа вместо композиции мы можем избежать упаковки ([[Structs with interfaces +]]).

Параметризация в сочетании с наследованием также может использоваться для реализации шаблона [[Curiously Recurring Template +]], поскольку мы также можем воспользоваться преимуществами статического полиморфизма, если производительность динамического полиморфизма имеет значение.

## Общие рекомендации
*Вместо наследования следует предпочитать композицию.* При наследовании весь функционал класса-наследника жестко определен на этапе компиляции. И во время выполнения программы мы не можем его динамически переопределить. А класс-наследник не всегда может переопределить код, который определен в родительском классе. Композиция же позволяет динамически определять поведение объекта во время выполнения, и поэтому является более гибкой.

*Вместо композиции следует предпочитать агрегацию*, как более гибкий способ связи компонентов. В то же время не всегда агрегация уместна. Например, у нас есть класс человека, который содержит объект нервной системы. Понятно, что в реальности, по крайней мере на текущий момент, невозможно вовне определить нервную систему и внедрить ее в человека. То есть в данном случае человек будет главным компонентом, а нервная система - зависимым, подчиненным, и их создание и жизненный цикл будет происходить совместно, поэтому здесь лучше выбрать композицию.