#oop
## Почему зависимости это плохо
Зависимости плохи так как они уменьшают переиспользование кода. Допустим, есть класс, который может читать список событий из XML:

```cs
public class CalendarReader {
    public List readCalendarEvents(File calendarEventFile){
        //open InputStream from File and read calendar events.
    }
}
```

Метод принимает File в качестве аргумента, соответственно, он ависит от него. Т. е. он не сможет получать данные по сети, из базы данных. 

`InputStream` можно получить как из файла, так и из сетевого соединения.
```cs
public class CalendarReader {
    public List readCalendarEvents(InputStream calendarEventFile){
        //read calendar events from InputStream
    }
}
```

## Типы зависимостей
+ Зависимость от классов
+ Зависимость от интерфейсов
+ Зависимость от методов / полей

Пример зависимости от класса - метод принимает String как параметр, т. е. зависит от класса `String`:

```cs
public byte[] readFileContents(String fileName){
    //open the file and return the contents as a byte array.
}
```

Пример зависимости от интерфейса - метод принимает `CharSequence` как параметр, при этом `String`, `CharBuffer`, `StringBuffer` и т. д. реализуют этот интерфейс (эти классы в контексте Java). 

```cs
public byte[] readFileContents(CharSequence fileName){
    //open the file and return the contents as a byte array.
}
```

Пример зависимости от метода - метод `readFileContents` зависит от метода `getFileName`, при этом зависимость не видна из определения метода:

```cs
public byte[] readFileContents(Object fileNameContainer){

    Method method   = fileNameContainer
                          .getClass()
                          .getMethod("getFileName", null);

    String fileName = method.invoke(fileNameContainer, null);

    //open the file and return the contents as a byte array.
}
```

Зависимости от методов обычны в API, которые используют рефлексию или в языках, поддерживающих указатели на методы, которые можно передавать как параметры (делегаты в C#)

## Дополнительные характеристики зависимости

### Зависимости реализации интерфейса
Если класс A зависит от интерфейса I, то A не зависит от конкретной реализации I. Но A зависит от некоторой реализации I. A не может выполнять свою работу без некоторой реализации I. Следовательно, всякий раз, когда класс зависит от интерфейса, этот класс также зависит от реализации.

Чем больше методов у интерфейса, тем меньше вероятность, что разработчики предоставят собственную реализацию для этого интерфейса, если только это не требуется. Поэтому, чем больше методов у интерфейса, тем больше вероятность, что разработчики просто будут придерживаться реализации этого интерфейса по умолчанию. Другими словами, чем больше и сложнее становится интерфейс, тем теснее он связан со своей реализацией по умолчанию!

Из-за зависимостей реализации интерфейса не следует слепо добавлять функциональность в интерфейс. Если функциональность может быть инкапсулирована в ее собственном компоненте, за ее собственным интерфейсом, вам следует это сделать.

Представьте, что вы хотите иметь возможность подсчитывать потомков узла. Сначала у вас может возникнуть соблазн добавить `countDescendents()` метод к интерфейсу `ITreeNode`. Однако, если вы это сделаете, любому, кто захочет реализовать интерфейс `ITreeNode`, также придется реализовать метод `countDescendent()`.

```cs
public interface ITreeNode {
    public void            addChild(ITreeNode node);
    public List<ITreeNode> getChildren();
    public ITreeNode       getParent();
}
```

Вместо этого вы могли бы реализовать класс `DescendentCounter`, который может пройти по `ITreeNode`экземпляру и подсчитать всех потомков этого экземпляра. `DescendentCounter`можно использовать повторно с различными реализациями интерфейса `ITreeNode`. Вы только что избавили своих пользователей от необходимости реализовывать метод `countDescendents()` , даже если им нужно реализовать интерфейс `ITreeNode`!

### Compile-time and Runtime Dependencies
Зависимость, которая может быть разрешена во время компиляции, является зависимостью времени компиляции. Зависимость, которая не может быть разрешена до времени выполнения, является зависимостью времени выполнения. Зависимости времени компиляции, как правило, легче увидеть разработчикам, чем зависимости времени выполнения, но иногда зависимости времени выполнения могут быть более гибкими.

### Видимые и скрытые зависимости
Видимая зависимость — это зависимость, которую разработчики могут видеть из интерфейса класса. Если зависимость не видна из интерфейса класса, то это скрытая зависимость.

В предыдущих примерах зависимости от `String` и `CharSequence` метода `readFileContents()` являются видимыми зависимостями. Они видны из объявления метода, которое является частью интерфейса класса. Зависимости метода `readFileContents()`, которые принимают `Object` в качестве параметра, невидимы. Из интерфейса нельзя увидеть, вызывает ли метод `readFileContents()` для `fileNameContainer.toString()`получения имени файла или, как он на самом деле делает, вызывает метод `getFileName()`.

Другим примером скрытой зависимости является зависимость от статического синглтона или статических методов внутри метода. Из интерфейса нельзя увидеть, зависит ли класс от статических методов или статических синглтонов.

Это не то же самое, что сказать, что вы никогда не должны использовать скрытые зависимости. Скрытые зависимости часто являются результатом предоставления разумных значений по умолчанию . Например, в этом примере это может не быть проблемой:

`MyComponent`имеет скрытую зависимость от `MyDefaultImpl`как вы можете видеть в первом конструкторе. Но если `MyDefaultImpl` не имеет никаких опасных побочных эффектов, то эта скрытая зависимость не опасна.

```cs
public class MyComponent{

  protected MyDependency dependency = null;

   public MyComponent(){
       this.dependency = new MyDefaultImpl();
       }

  public MyComponent(MyDependency dependency){
    this.dependency = dependency;
  }
}
```

### Прямые и косвенные зависимости
Зависимость может быть как прямой, так и косвенной. Если класс A использует класс B, то A имеет прямую зависимость от B. Если A зависит от B, а B зависит от C, то A имеет косвенную зависимость от C. Если вы не можете использовать A без B, и не можете использовать B без C, то вы также не можете использовать A без C.

### Неоправданно обширные зависимости
Иногда компоненты зависят от большего количества информации, чем им нужно для выполнения своей работы. Например, представьте себе компонент входа в веб-приложение. Компоненту входа нужны только имя пользователя и пароль, и он вернет объект пользователя, если таковой имеется, который им соответствует. Интерфейс может выглядеть так:

```cs
public class LoginManager{
    
  public User login(HttpServletRequest request){
    String user     = request.getParameter("user");
    String password = request.getParameter("password");

    //read user and return it.
  }
}
```

Вызов компонента будет выглядеть так:

```cs
LoginManager loginManager = new LoginManager();
User         user         = loginManager.login(request);
```

Выглядит просто, и даже, если методу входа понадобится больше параметров, вам не нужно менять вызывающий код. Но этот метод имеет неоправданно обширную зависимость от интерфейса `HttpServletRequest`. `LoginManager` нуждается только в име пользователя и пароле, чтобы найти пользователя, но принимает `HttpServletRequest` как параметр, `HttpServletRequest` содержит намного больше информации, чем нужно `LoginManager`.

Зависимость от интерфейса `HttpServletRequest` вызывает две проблемы:
1. `LoginManager` не может быть переиспользован без экземпляра `HttpServletRequest`, это может усложнить тестирование
2. `LoginManager` требует, чтобы параметры имели значения "user" и "password", это тоже ненужная зависимость

Другой подход:
```cs
public User login(String user, String password){
    //read user and return it.
}
```

Но посмотрите, что теперь происходит с вызывающим кодом:

```cs
LoginManager loginManager = new LoginManager();
User user = loginManager.login(
    request.getParameter("user"),
    request.getParameter("password"));
```

Он становится более сложным. Для компонента, который принимает 5 параметров запроса для выполнения своей работы, это будет выглядеть еще хуже. Это главная причина, по которой разработчики создают неоправданно обширные зависимости. Для упрощения вызывающего кода.

### Локальные и контекстные зависимости
При разработке приложений принято разбивать приложение на мелкие компоненты. Некоторые из этих компонентов являются компонентами общего назначения, которые могут быть полезны и в других приложениях. Некоторые компоненты являются специфическими для приложения и не имеют никакого применения вне приложения.

Для компонента общего назначения любые классы, принадлежащие компоненту (или API), являются «локальными». Остальная часть приложения — это «контекст». Если компонент общего назначения зависит от классов, специфичных для приложения, это называется «зависимостью от контекста». Зависимости от контекста плохи, потому что они делают компонент общего назначения непригодным для использования вне приложения.

Возникает соблазн думать, что только плохой OO-дизайнер будет создавать контекстные зависимости, но это не так. Контекстные зависимости часто возникают, когда разработчики пытаются упростить дизайн своего приложения. Хорошим примером этого являются приложения обработки запросов, такие как приложения, подключенные к очереди сообщений, или веб-приложения.

Представьте себе приложение, которое получает запрос в форме XML, обрабатывает запросы и отправляет обратно результат в форме XML. Во время обработки запрос XML обрабатывается несколькими отдельными компонентами. Каждому из этих компонентов нужна разная информация, часть которой была создана более ранними компонентами. Очень заманчиво собрать файл XML и всю связанную обработку внутри некоторого объекта запроса, который передается всем компонентам в последовательности обработки. Затем компоненты обработки могут считывать информацию из этого объекта запроса и прикреплять к нему дополнительную информацию для использования более поздними компонентами обработки. Принимая этот объект запроса в качестве параметра, каждый из компонентов обработки запроса зависит от этого объекта запроса. Объект запроса специфичен для приложения, поэтому каждый компонент обработки запроса имеет контекстную зависимость.

## Стандартные и пользовательские зависимости классов/интерфейсов
Во многих ситуациях лучше, чтобы компонент зависел от класса или интерфейса из стандартных пакетов Java (или C# и т. д.). Эти классы и интерфейсы всегда доступны любому, что упрощает удовлетворение зависимостей этих компонентов. Кроме того, эти классы с меньшей вероятностью изменятся и приведут к сбою компиляции вашего приложения.