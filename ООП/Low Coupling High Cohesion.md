#oop 
Coupling относится к степени взаимозависимости между программными модулями. Высокая связанность означает, что модули тесно связаны, и изменения в одном модуле могут повлиять на другие модули. Низкая связанность означает, что модули независимы, и изменения в одном модуле оказывают незначительное влияние на другие модули.

Cohesion относится к степени, в которой элементы в модуле работают вместе для выполнения одной, четко определенной цели. Высокая сплоченность означает, что элементы тесно связаны и сосредоточены на одной цели, в то время как низкая сплоченность означает, что элементы слабо связаны и служат нескольким целям.

По сути, проектирование — это двухэтапный итеративный процесс. Первая часть — это концептуальное проектирование, которое сообщает заказчику, что будет делать система. Вторая часть — это техническое проектирование, которое позволяет разработчикам систем понять фактическое аппаратное и программное обеспечение, необходимое для решения проблемы заказчика.

Модуляризация — это процесс разделения программной системы на несколько независимых модулей, где каждый модуль работает независимо. Существует множество преимуществ модуляризации в программной инженерии. Некоторые из них приведены ниже: 

- Простая для понимания система.
- Техническое обслуживание системы простое.
- Модуль может использоваться много раз по мере необходимости. Нет необходимости писать его снова и снова.

## Типы Coupling'а
> [!info] Coupling — это мера степени взаимозависимости между модулями. Хорошее программное обеспечение будет иметь низкую связанность.

![[coupling.png]]

- **Data Coupling**. Если зависимость между модулями основана на том факте, что они взаимодействуют, передавая только данные, то говорят, что модули связаны данными. При сцеплении данных компоненты независимы друг от друга и взаимодействуют посредством данных. Коммуникации модулей не содержат [[Tramp Data]].
  
- **Stamp Coupling**. Полная структура данных передается из одного модуля в другой. Поэтому она включает в себя [[Tramp Data]]. Это может быть необходимо из-за факторов эффективности — этот выбор был сделан проницательным дизайнером, а не ленивым программистом.
  
- **Control Coupling**. Если модули взаимодействуют путем передачи управляющей информации, то говорят, что они связаны управлением. Это может быть плохо, если параметры указывают на совершенно разное поведение, и хорошо, если параметры допускают факторизацию и повторное использование функциональности. Пример — функция сортировки, которая принимает функцию сравнения в качестве аргумента.
  
- **External Coupling**. Модули зависят от других модулей, внешних по отношению к разрабатываемому программному обеспечению или к определенному типу оборудования. Например, протокол, внешний файл, формат устройства и т. д.
  
- **Common Coupling**. Модули имеют общие данные, такие как глобальные структуры данных. Изменения в глобальных данных означают отслеживание всех модулей, которые обращаются к этим данным, для оценки эффекта изменения. Поэтому у него есть недостатки, такие как сложность повторного использования модулей, сниженная способность контролировать доступ к данным и сниженная пригодность для рефакторинга.
  
- **Content Coupling**. Один модуль может изменять данные другого модуля, или поток управления передается от одного модуля к другому. Это худшая форма связывания, и ее следует избегать.
  
- **[[Temporal Coupling +]]** Два модуля зависят от времени или порядка событий, например, один модуль должен выполниться раньше другого. Этот тип сопряжения может привести к проблемам проектирования и трудностям в тестировании и обслуживании.
  
- **Sequential Coupling**. Выход одного модуля используется как вход другого модуля, создавая цепочку или последовательность зависимостей. Этот тип соединения может быть сложным для поддержания и изменения.
  
- **Communicational Coupling**. Два или более модулей совместно используют общий механизм связи, например общую очередь сообщений или базу данных. Этот тип сопряжения может привести к проблемам с производительностью и трудностям в отладке.
  
- **Functional Coupling**. Два модуля зависят от функциональности друг друга, например, один модуль вызывает функцию из другого модуля. Этот тип связывания может привести к тесно связанному коду, который трудно модифицировать и поддерживать.
  
- **Data-Structured Coupling**. Два или более модулей совместно используют общую структуру данных, например таблицу базы данных или файл данных. Этот тип сцепления может привести к трудностям в поддержании целостности структуры данных и может вызвать проблемы с производительностью.
  
- **Interaction Coupling**. Методы класса вызывают методы других классов. Как и в случае с функциями, наихудшая форма связывания здесь — если методы напрямую обращаются к внутренним частям других методов. Связывание наименьшее, если методы взаимодействуют напрямую через параметры.
  
- **Component Coupling**. Относится к взаимодействию между двумя классами, где класс содержит переменные  другого класса. Существуют три четкие ситуации относительно того, как это может произойти. 
	- Класс `C` может быть компонентно связан с другим классом `C1`, если `C` имеет переменную экземпляра типа `C1`
	- Класс `C` имеет метод, параметр которого имеет тип `C1`
	- Класс `C` имеет метод, который имеет локальную переменную типа `C1`. 
	  
	  Должно быть ясно, что всякий раз, когда есть связывание компонентов, вероятно, будет и связывание взаимодействия.

## Типы Cohesion
> [!info] Cohesion - это мера степени, в которой элементы модуля функционально связаны. Это степень, в которой все элементы, направленные на выполнение одной задачи, содержатся в компоненте. По сути, cohesion — это внутренний клей, который удерживает модуль вместе. Хороший дизайн программного обеспечения будет иметь высокую сплоченность.

![[cohesion.png]]

- **Function**. Каждый существенный элемент для отдельного вычисления содержится в компоненте. Функциональная связность выполняет задачу и функции. Это идеальная ситуация.
  
- **Sequence**. Элемент выводит некоторые данные, которые становятся входными для другого элемента, т. е. поток данных между частями. Это происходит естественным образом в функциональных языках программирования.
  
- **Communicational**. Два элемента работают с одними и теми же входными данными или вносят вклад в одни и те же выходные данные. Пример — обновить запись в базе данных и отправить ее на принтер.
  
- **Procedural**. Элементы обеспечивают порядок выполнения. Действия все еще слабо связаны и вряд ли будут повторно использоваться. Пример: вычислить средний балл учащегося, распечатать студенческую запись, вычислить кумулятивный средний балл, распечатать кумулятивный средний балл.
  
- **Temporal**. Элементы связаны между собой по времени. В модуле, связанном временной связью, все задачи должны выполняться в один и тот же промежуток времени. Эта связность содержит код для инициализации всех частей системы. Происходит множество различных действий, и все они выполняются в единицу времени.

- **Logical**. Элементы связаны логически, а не функционально. Пример: компонент считывает входные данные с ленты, диска и сети. Весь код для этих функций находится в одном компоненте. Операции связаны, но функции существенно различаются.
  
- **Coincidental**. Элементы не имеют концептуальной связи, кроме расположения в исходном коде.
  
- **Informational**. Информационная связность возникает, когда элементы или задачи группируются в модуле на основе их связи с определенной структурой данных или объектом, например, модуль, который работает с определенным типом данных или объектом. Информационная связность обычно используется в объектно-ориентированном программировании.
  
- **Layer**. Возникает, когда элементы или задачи в модуле группируются вместе на основе их уровня абстракции или ответственности, например, модуль, который обрабатывает только низкоуровневые аппаратные взаимодействия, или модуль, который обрабатывает только высокоуровневую бизнес-логику. Сплоченность слоев обычно используется в крупномасштабных программных системах для организации кода в управляемые слои.

## Преимущества low coupling
- **Улучшенная поддерживаемость**: низкая степень связанности снижает влияние изменений в одном модуле на другие модули, что упрощает модификацию или замену отдельных компонентов без влияния на всю систему.
- **Улучшенная модульность**: низкая связанность позволяет разрабатывать и тестировать модули изолированно, что улучшает модульность и возможность повторного использования кода.
- **Лучшая масштабируемость**: низкая степень связанности упрощает добавление новых модулей и удаление существующих, что упрощает масштабирование системы по мере необходимости.

## Недостатки high coupling
- **Повышенная сложность**: высокая степень связанности увеличивает взаимозависимость между модулями, что делает систему более сложной и трудной для понимания.
- **Снижение гибкости**: высокая степень связанности затрудняет модификацию или замену отдельных компонентов без влияния на всю систему.
- **Снижение модульности**: высокая степень связанности затрудняет разработку и тестирование модулей по отдельности, что снижает модульность и возможность повторного использования кода.

## Преимущества high cohesion
- **Улучшенная читаемость и понятность:** высокая степень связности приводит к созданию четких, целенаправленных модулей с единой, четко определенной целью, что упрощает понимание кода и внесение изменений.
- **Лучшая изоляция ошибок**: высокая степень связности снижает вероятность того, что изменение в одной части модуля повлияет на другие части. 
- **Повышенная надежность**: высокая степень связности приводит к тому, что модули менее подвержены ошибкам и работают более согласованно, что приводит к общему повышению надежности системы.

## Недостатки low cohesion
- **Увеличение дублирования кода**: низкая связность может привести к дублированию кода, поскольку элементы, которые связаны друг с другом, разбиваются на отдельные модули.
- **Снижение функциональности**: Низкая связность может привести к появлению модулей, не имеющих четкого назначения и содержащих элементы, не соответствующие друг другу, что снижает их функциональность и затрудняет их поддержку.
- **Сложность понимания модуля**: низкая связность может затруднить разработчикам понимание назначения и поведения модуля, что приведет к ошибкам и отсутствию ясности.