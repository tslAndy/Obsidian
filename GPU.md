## 3D Модели
Модель сделана из полигонов - плоских фигур, состоящих из линий. Чаще всего используются четырехугольники, так как 3D-художникам легко с ними работать. 

## Триангуляция
Для преобразования полигонов в треугольники используется триангуляция. Полигон может быть либо Convex либо Concave.

Convex:
- "выгнутый"
- внутренние углы меньше 180
- любая линия, проходящая через полигон, пересечет только 2 ребра
- триангуляция выполняется путем соединения случайно выбранной точки полигона со всеми остальными, пропуская две соседние точки рядом с выбранной (так как они уже соединены).

Concave:
- "вогнутый"
- минимум один внутренний угол больше 180
- есть минимум одна линия, которая пересечет 4 ребра
- лучше вообще не использовать, так как алгоритмы для триангуляции такого полигона сложны

## Vertex Buffer
Хранит аттрибуты вершин (vertex attributes). Это позиция вершин и при необходимости другие данные. Порядок, в котором сохранены вершины, имеет значение. Другими данными могут быть цвета вершин или соответствующая позиция в UV-развертке. Эти данные интерполируются для каждого пикселя и передаются в fragment shader. 

## Index Buffer
Допустим, мы хотим нарисовать квадрат. Как вариант, мы можем добавить два треугольника, но в таком случае будет дублирование информации, так как две вершины будут и в первом, и во втором треугольнике. Вместо этого присваиваем каждой вершине номер, и используем эти номера для создания двух треугольников, избегая дублирования информации.

## Vertex Normal
Нормаль треугольника - единичный вектор, указывающий перпендикулярно его поверхности. Допустим, у нас есть треугольник ABC. Для нахождения нормали находим вектора AB и AC, затем находим произведение этих векторов (cross product). Здесь становится важным, в каком порядке были сохранены вершины, так как векторы AB и AC строятся согласно порядку, и нормали будут указывать в противоположных направлениях, и это будет указывать на то, является ли сторона передней или задней. 

После вычисления нормали сохраняем ее в каждую из вершин треугольника. Проблема в том, что нормали уникальны для каждого треугольника, и если вершина входит не только в один треугольник, нужно сохранить в вершину "среднюю нормаль", вычисляя нормали каждого треугольника, в который входит вершина, и находя среднее арифметическое. 

## UV-mapping
Для каждой вершины нужно найти нормализованную позицию соответствующего пикселя из текстуры. Может быть так, что одна вершина может соответствовать двум позициям на текстуре, в таком случае дублируем вершину и записываем разные UV-координаты в каждую. 

## Sampler
Определяет цвет, соответствующий UV-координате, основываясь на адресации и фильтрации.

### Addressing 
Если UV-координата не находится в диапазоне между (0, 0) и (1, 1), то можно использовать разные виды отражения / повторения, которые преобразуют "неправильную" координату в правильный диапазон. 

### Filtering
Так как uv-координата пикселя после интерполяции не обязательно будет соответстволвать одному пикселю (при наличии дробной части), то нужна какая-то функция, которая будет смешивать цвет с соседним. 

Есть тексели - точки с цветом (соответствуют пикселям). Например это тексели 
a b
c d
и какая-то точка между ними.

Для нахождения цвета точки нужно линейно интерполировать на основе x-координаты точки цвета (a и b) затем (c и d), затем на основе y-координаты между двумя получившимися значениями. Это называется билинейая интерполяция. 

## Mipmapping
При текстурировании будет выбираться наиболее подходящая по размеру текстура в зависимости от удаленности объекта от камеры.

Состовляем цепочку текстур, каждая из которых размером в 4 раза меньше предыдущей (сторона в 2 раза меньше). Цвет пиксля в следующей текстуре определяется билинейной интерполяцией. 

Допустим, есть текстура 5x5. Для нахождение цвета точки, мы берем текстуру размером 4x4 и 8x8. Вычислить размер текстур, одна из которых меньше, а другая больше, можно с помощью округления в меньшую или большую сторону log2 из 5. Находим два текселя в текстурах, сооответствующих данной точке, и линейно интерполируем по формуле t = (L - a) / (b - a), где L = 5, a = 4, b = 8. Это называется триленейная интерполяция. 

## GPU Pipeline
### Input Assembler
Принимает на вход vertex buffer, содержащий аттрибуты вершин всех треугольников. Указываем, какие данные используются в вершине. Input Assembler может доавлять дополнительные данные, например id вершины. 

### Vertex Shader
Каждый вертекс после Input Assembler попадает в вершинный шейдер. Он преобразует это в новые данные (например, трансформирует позицию), может оставлять данные нетронутыми или добавлять новые (например, присваивать цвет вершине). Преобразованная вертексным шейдером позиция должна быть в диапазоне от -1 до 1 по каждой координате. 

## Tesselation
- Hull Shader
- Tesselator
- Domain Shader

Tesselation принимает на вход примитив, например квадрат, и создает детализированную версию, содержащую много треугольников. Упрощенно говоря, hull shader определяет паттерн треугольников, tesselator создаст эти треугольники, основываясь на паттерне, и domain shader расположит эти треугольники, основываясь на определенных формулах. 

## Geometry Shader
Принимает на вход какие-то примитивы, например треугольники, линии или точки. Может оставить входные данные без изменения, либо добавить новые вершины. 

## Rasterizer
Получает треугольники и преобразует в пиксели, которые будут отображены на экране. Для корректной растеризации объектов в зависимости их близости от камеры используется depth buffer. Конвертируем z-координату в цвет, получая расстояние до камеры. Чем ближе объект к камере, тем темнее цвет. Rasterizer интерполирует данные вертексов треугольника (например uv-координата, цвет, нормаль и так далее) для каждого пикселя в его растеризации. 

## Pixel Shader
Принимает интерполированные данные для каждого пикселя и выдает цвет. Делает это основываясь на texture или sampler. 

## Output Merger
Принимает цвет и глубину пикселя, при необходимости может получать текущее значение пикселя (старое) и выполнять blending, либо без изменений передавать входные данные. Затем сравнивает значение глубины входного пикселя и уже имеющегося, и если новый пиксель "ближе", то заменяет значения цвета и глубины. 